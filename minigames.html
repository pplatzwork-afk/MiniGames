<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini-Games Collection</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(255,255,255,0.3); }
            to { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(255,255,255,0.5); }
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
        }

        .nav-tab {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .nav-tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .game-screen {
            display: none;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            animation: fadeIn 0.5s ease-in;
        }

        .game-screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .main-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .game-card {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .game-card:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .game-card h3 {
            margin-bottom: 10px;
            font-size: 1.4rem;
        }

        .game-card p {
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .play-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-content {
            text-align: center;
            min-height: 400px;
        }

        .game-title {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .game-controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .btn.secondary {
            background: linear-gradient(45deg, #607d8b, #455a64);
        }

        .game-area {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .score-display {
            font-size: 1.5rem;
            margin: 15px 0;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(0,0,0,0.1);
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input, .input-group select {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: 0 auto;
        }

        .memory-card {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: all 0.3s ease;
            user-select: none;
        }

        .memory-card:hover {
            transform: scale(1.05);
        }

        .memory-card.flipped {
            background: rgba(255,255,255,0.4);
        }

        .typing-text {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2rem;
            line-height: 1.6;
            margin: 20px 0;
        }

        .typing-input {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-family: monospace;
        }

        .simon-button {
            width: 80px;
            height: 80px;
            margin: 5px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 4px solid rgba(255,255,255,0.3);
        }

        .simon-button:hover {
            transform: scale(1.1);
        }

        .simon-button.red { background: #f44336; }
        .simon-button.blue { background: #2196F3; }
        .simon-button.green { background: #4CAF50; }
        .simon-button.yellow { background: #FFEB3B; }

        .simon-button.active {
            transform: scale(1.2);
            filter: brightness(1.5);
            box-shadow: 0 0 20px currentColor;
        }

        .achievements {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .achievement {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            position: relative;
        }

        .achievement.unlocked {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            animation: achievementUnlock 0.5s ease-out;
        }

        @keyframes achievementUnlock {
            from { transform: scale(0.8) rotate(-5deg); }
            to { transform: scale(1) rotate(0deg); }
        }

        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        /* Game Completion Modal */
        .game-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .modal-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #fff;
        }

        .modal-score {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #4CAF50;
            font-weight: bold;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }

        .modal-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border-color: #4CAF50;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .nav-tabs {
                flex-direction: column;
                align-items: center;
            }

            .game-screen {
                padding: 20px;
            }

            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
                max-width: 300px;
            }

            .simon-button {
                width: 60px;
                height: 60px;
            }

            .modal-content {
                padding: 30px 20px;
            }

            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 Mini-Games Collection</h1>
            <p>Challenge yourself with 8 exciting games!</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showScreen('menu')">🏠 Menu</button>
            <button class="nav-tab" onclick="showScreen('snake')">🐍 Snake</button>
            <button class="nav-tab" onclick="showScreen('memory')">🧠 Memory</button>
            <button class="nav-tab" onclick="showScreen('reaction')">⚡ Reaction</button>
            <button class="nav-tab" onclick="showScreen('guess')">🔢 Guess</button>
            <button class="nav-tab" onclick="showScreen('typing')">⌨️ Typing</button>
            <button class="nav-tab" onclick="showScreen('color')">🎨 Color</button>
            <button class="nav-tab" onclick="showScreen('math')">➕ Math</button>
            <button class="nav-tab" onclick="showScreen('simon')">🎵 Simon</button>
            <button class="nav-tab" onclick="showScreen('stats')">📊 Stats</button>
        </div>

        <!-- Main Menu -->
        <div id="menu-screen" class="game-screen active">
            <div class="main-menu">
                <div class="game-card" onclick="showScreen('snake')">
                    <h3>🐍 Snake Game</h3>
                    <p>Classic snake with growing tail. Collect food and avoid walls!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('memory')">
                    <h3>🧠 Memory Match</h3>
                    <p>Flip cards to find matching pairs. Test your memory skills!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('reaction')">
                    <h3>⚡ Reaction Time</h3>
                    <p>Click when the color changes. How fast are your reflexes?</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('guess')">
                    <h3>🔢 Number Guess</h3>
                    <p>Guess the secret number in as few tries as possible!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('typing')">
                    <h3>⌨️ Typing Speed</h3>
                    <p>Test your words per minute. Type as fast and accurately as possible!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('color')">
                    <h3>🎨 Color Match</h3>
                    <p>Match the color name with the correct color. Don't be fooled!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('math')">
                    <h3>➕ Math Quiz</h3>
                    <p>Rapid-fire arithmetic questions. How many can you solve?</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('simon')">
                    <h3>🎵 Simon Says</h3>
                    <p>Repeat the sequence of colors. Memory and timing combined!</p>
                    <button class="play-btn">Play Now</button>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-games">0</div>
                    <div class="stat-label">Total Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-time">0m</div>
                    <div class="stat-label">Total Time Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="achievements-count">0</div>
                    <div class="stat-label">Achievements Unlocked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="current-streak">0</div>
                    <div class="stat-label">Current Win Streak</div>
                </div>
            </div>
        </div>

        <!-- Snake Game -->
        <div id="snake-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🐍 Snake Game</h2>
                <div class="score-display">Score: <span id="snake-score">0</span></div>
                <div class="game-area">
                    <canvas id="snake-canvas" class="canvas" width="400" height="400"></canvas>
                </div>
                <div class="game-controls">
                    <button class="btn" id="snake-start" onclick="startSnake()">Start Game</button>
                    <button class="btn secondary" id="snake-pause" onclick="pauseSnake()" disabled>Pause</button>
                    <button class="btn danger" onclick="resetSnake()">Reset</button>
                    <select id="snake-difficulty">
                        <option value="easy">Easy (Slow)</option>
                        <option value="medium" selected>Medium (Normal)</option>
                        <option value="hard">Hard (Fast)</option>
                    </select>
                    <select id="snake-mode">
                        <option value="classic">Classic Mode</option>
                        <option value="accelerate">Accelerating Mode</option>
                    </select>
                </div>
                <p>Use WASD or Arrow keys to control the snake</p>
            </div>
        </div>

        <!-- Memory Game -->
        <div id="memory-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🧠 Memory Match</h2>
                <div class="score-display">
                    Moves: <span id="memory-moves">0</span> | 
                    Pairs: <span id="memory-pairs">0</span>/8
                </div>
                <div class="game-area">
                    <div id="memory-grid" class="memory-grid"></div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startMemory()">New Game</button>
                    <select id="memory-difficulty">
                        <option value="easy">Easy (3x4)</option>
                        <option value="medium" selected>Medium (4x4)</option>
                        <option value="hard">Hard (5x4)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Reaction Time -->
        <div id="reaction-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">⚡ Reaction Time Test</h2>
                <div class="score-display">Best Time: <span id="reaction-best">N/A</span>ms</div>
                <div class="game-area">
                    <div id="reaction-area" style="width: 300px; height: 200px; background: #f44336; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.5rem; transition: all 0.3s ease; position: relative;">
                        <div id="reaction-circle" style="width: 50px; height: 50px; background: #4CAF50; border-radius: 50%; position: absolute; display: none; cursor: pointer;"></div>
                        <span id="reaction-text">Click to Start</span>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startReaction()">Start Test</button>
                    <button class="btn secondary" onclick="resetReaction()">Reset</button>
                    <select id="reaction-mode">
                        <option value="area">Click Area Mode</option>
                        <option value="circle">Click Circle Mode</option>
                    </select>
                </div>
                <p id="reaction-status">Click "Start Test" to begin</p>
            </div>
        </div>

        <!-- Number Guessing -->
        <div id="guess-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🔢 Number Guessing Game</h2>
                <div class="score-display">
                    Attempts: <span id="guess-attempts">0</span> | 
                    Best: <span id="guess-best">N/A</span>
                </div>
                <div class="game-area">
                    <div class="input-group">
                        <label for="guess-input">Guess a number between 1 and 100:</label>
                        <input type="number" id="guess-input" min="1" max="100" placeholder="Enter your guess">
                    </div>
                    <div class="game-controls">
                        <button class="btn" onclick="makeGuess()">Submit Guess</button>
                        <button class="btn secondary" onclick="startGuessing()">New Game</button>
                        <select id="guess-difficulty">
                            <option value="easy">Easy (1-50)</option>
                            <option value="medium" selected>Medium (1-100)</option>
                            <option value="hard">Hard (1-500)</option>
                        </select>
                    </div>
                    <div id="guess-feedback" style="margin-top: 20px; font-size: 1.2rem;"></div>
                    <div id="guess-hints" style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; display: none;">
                        <strong>Hint:</strong> <span id="hint-text"></span>
                    </div>
                    <div id="guess-history" style="margin-top: 15px; font-size: 0.9rem; opacity: 0.8;"></div>
                </div>
            </div>
        </div>

        <!-- Typing Speed Test -->
        <div id="typing-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">⌨️ Typing Speed Test</h2>
                <div class="score-display">
                    WPM: <span id="typing-wpm">0</span> | 
                    Accuracy: <span id="typing-accuracy">100%</span>
                </div>
                <div class="game-area">
                    <div id="typing-text" class="typing-text"></div>
                    <input type="text" id="typing-input" class="typing-input" placeholder="Start typing here..." disabled>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startTyping()">Start Test</button>
                    <button class="btn secondary" onclick="resetTyping()">Reset</button>
                    <select id="typing-duration">
                        <option value="30">30 seconds</option>
                        <option value="60" selected>60 seconds</option>
                        <option value="120">2 minutes</option>
                    </select>
                    <select id="typing-difficulty">
                        <option value="easy">Easy (Simple words)</option>
                        <option value="medium" selected>Medium (Mixed text)</option>
                        <option value="hard">Hard (Complex text)</option>
                        <option value="code">Coding (Code snippets)</option>
                    </select>
                </div>
                <div class="score-display">
                    Time: <span id="typing-timer">60</span>s | 
                    Raw WPM: <span id="typing-raw-wpm">0</span> | 
                    Errors: <span id="typing-errors">0</span>
                </div>
            </div>
        </div>

        <!-- Color Matcher -->
        <div id="color-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🎨 Color Matcher</h2>
                <div class="score-display">
                    Score: <span id="color-score">0</span> | 
                    Streak: <span id="color-streak">0</span> | 
                    Time: <span id="color-timer">30</span>s
                </div>
                <div class="game-area">
                    <div id="color-word" style="font-size: 3rem; margin: 20px; font-weight: bold;">RED</div>
                    <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                        <button class="btn" onclick="selectColor('red')" style="background: #f44336;">Red</button>
                        <button class="btn" onclick="selectColor('blue')" style="background: #2196F3;">Blue</button>
                        <button class="btn" onclick="selectColor('green')" style="background: #4CAF50;">Green</button>
                        <button class="btn" onclick="selectColor('yellow')" style="background: #FFEB3B; color: black;">Yellow</button>
                        <button class="btn" onclick="selectColor('purple')" style="background: #9C27B0;">Purple</button>
                        <button class="btn" onclick="selectColor('orange')" style="background: #FF9800;">Orange</button>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startColorMatch()">Start Game</button>
                    <button class="btn secondary" onclick="resetColorMatch()">Reset</button>
                </div>
                <p id="color-feedback">Match the meaning of the word, not its color!</p>
            </div>
        </div>

        <!-- Math Quiz -->
        <div id="math-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">➕ Math Quiz</h2>
                <div class="score-display">
                    Score: <span id="math-score">0</span> | 
                    Time: <span id="math-timer">30</span>s
                </div>
                <div class="game-area">
                    <div id="math-question" style="font-size: 2.5rem; margin: 20px;">Press Start to Begin</div>
                    <div class="input-group">
                        <input type="number" id="math-input" placeholder="Enter your answer" disabled>
                    </div>
                    <div class="game-controls">
                        <button class="btn" onclick="submitMath()">Submit</button>
                        <button class="btn secondary" onclick="skipMath()">Skip</button>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startMath()">Start Quiz</button>
                    <button class="btn secondary" onclick="resetMath()">Reset</button>
                    <select id="math-difficulty">
                        <option value="easy">Easy (+, -)</option>
                        <option value="medium" selected>Medium (+, -, ×)</option>
                        <option value="hard">Hard (+, -, ×, ÷)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Simon Says -->
        <div id="simon-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🎵 Simon Says</h2>
                <div class="score-display">
                    Level: <span id="simon-level">0</span> | 
                    Best: <span id="simon-best">0</span>
                </div>
                <div class="game-area">
                    <div id="simon-buttons" style="display: flex; flex-wrap: wrap; justify-content: center; max-width: 400px; margin: 0 auto;">
                        <div class="simon-button red" onclick="simonClick('red')" data-color="red"></div>
                        <div class="simon-button blue" onclick="simonClick('blue')" data-color="blue"></div>
                        <div class="simon-button green" onclick="simonClick('green')" data-color="green"></div>
                        <div class="simon-button yellow" onclick="simonClick('yellow')" data-color="yellow"></div>
                        <div class="simon-button purple" onclick="simonClick('purple')" data-color="purple" style="display: none; background: #9C27B0;"></div>
                        <div class="simon-button orange" onclick="simonClick('orange')" data-color="orange" style="display: none; background: #FF9800;"></div>
                        <div class="simon-button cyan" onclick="simonClick('cyan')" data-color="cyan" style="display: none; background: #00BCD4;"></div>
                        <div class="simon-button pink" onclick="simonClick('pink')" data-color="pink" style="display: none; background: #E91E63;"></div>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startSimon()">Start Game</button>
                    <button class="btn secondary" onclick="resetSimon()">Reset</button>
                    <select id="simon-difficulty">
                        <option value="easy">Easy (4 colors)</option>
                        <option value="medium" selected>Medium (4 colors, faster)</option>
                        <option value="hard">Hard (6 colors)</option>
                        <option value="expert">Expert (8 colors)</option>
                    </select>
                </div>
                <p id="simon-status">Press Start to begin the sequence</p>
            </div>
        </div>

        <!-- Statistics Dashboard -->
        <div id="stats-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">📊 Statistics Dashboard</h2>
                <div class="game-controls">
                    <button class="btn secondary" onclick="exportStats()">Export Data</button>
                    <button class="btn danger" onclick="clearStats()">Clear All Stats</button>
                    <button class="btn" onclick="showSessionStats()">📊 Session Analytics</button>
                </div>
                
                <!-- Session Analytics Panel -->
                <div id="session-analytics" style="display: none; margin-bottom: 30px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                        <div class="stat-card">
                            <h3>🎯 Current Session</h3>
                            <div id="current-session-stats"></div>
                        </div>
                        <div class="stat-card">
                            <h3>📈 Performance Trends</h3>
                            <div id="performance-trends"></div>
                        </div>
                        <div class="stat-card">
                            <h3>🏆 Daily Progress</h3>
                            <div id="daily-progress"></div>
                        </div>
                        <div class="stat-card">
                            <h3>🎮 Live Metrics</h3>
                            <div id="live-metrics"></div>
                        </div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">📊 Performance Rating History</h3>
                        <canvas id="rating-chart" width="800" height="200" style="width: 100%; max-width: 800px; height: auto; background: rgba(0,0,0,0.1); border-radius: 10px;"></canvas>
                    </div>
                </div>
                
                <div id="stats-content"></div>
                
                <!-- Leaderboards Section -->
                <div style="margin: 30px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>🏆 Leaderboards</h3>
                        <button class="btn secondary" onclick="toggleLeaderboards()">Show/Hide Leaderboards</button>
                    </div>
                    <div id="leaderboards-section" style="display: none;">
                        <div id="leaderboards-content"></div>
                    </div>
                </div>
                
                <h3 style="margin-top: 30px; margin-bottom: 20px;">🏆 Achievements</h3>
                <div id="achievements-display" class="achievements"></div>
            </div>
        </div>
    </div>

    <script>
        // Statistics and Game State Management
        class GameStats {
            constructor() {
                this.data = this.loadStats();
                this.achievements = this.loadAchievements();
                this.sessionStart = Date.now();
            }

            loadStats() {
                const saved = localStorage.getItem('miniGameStats');
                if (!saved) return this.getDefaultStats();
                
                const data = JSON.parse(saved);
                // Migrate old data structure to new difficulty-based structure
                return this.migrateStats(data);
            }

            migrateStats(data) {
                const defaultStats = this.getDefaultStats();
                
                // Check if data needs migration (old structure)
                if (data.snake && typeof data.snake.gamesPlayed === 'number') {
                    // Migrate to new structure
                    Object.keys(data).forEach(game => {
                        if (game !== 'global' && data[game]) {
                            if (defaultStats[game]?.overall) {
                                // Copy old stats to overall
                                defaultStats[game].overall = { ...data[game] };
                            } else {
                                // Keep as-is for games without difficulty structure
                                defaultStats[game] = data[game];
                            }
                        }
                    });
                    defaultStats.global = data.global || defaultStats.global;
                    return defaultStats;
                }
                
                // Ensure all fields exist with defaults
                Object.keys(defaultStats).forEach(game => {
                    if (!data[game]) {
                        data[game] = defaultStats[game];
                    } else if (data[game].overall) {
                        // Ensure all difficulty levels exist
                        Object.keys(defaultStats[game]).forEach(difficulty => {
                            if (!data[game][difficulty]) {
                                data[game][difficulty] = defaultStats[game][difficulty];
                            }
                        });
                    }
                });
                
                return data;
            }

            getDefaultStats() {
                return {
                    snake: { 
                        easy: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        easy_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        easy_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        overall: { gamesPlayed: 0, highScore: 0, totalTime: 0, lastPlayed: null }
                    },
                    memory: { 
                        easy: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        medium: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        hard: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        overall: { gamesPlayed: 0, bestMoves: null, totalTime: 0, winRate: 0, wins: 0, lastPlayed: null }
                    },
                    reaction: { 
                        area: { gamesPlayed: 0, bestTime: null, totalTime: 0, tests: [] },
                        circle: { gamesPlayed: 0, bestTime: null, totalTime: 0, tests: [] },
                        overall: { gamesPlayed: 0, bestTime: null, averageTime: 0, totalTime: 0, tests: [], lastPlayed: null }
                    },
                    guess: { 
                        easy: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        medium: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        hard: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        overall: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0, winRate: 0, lastPlayed: null }
                    },
                    typing: { 
                        30: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        60: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        120: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        overall: { gamesPlayed: 0, bestWPM: 0, averageWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [], lastPlayed: null }
                    },
                    color: { gamesPlayed: 0, highScore: 0, bestStreak: 0, totalTime: 0, accuracy: 0, correct: 0, total: 0, lastPlayed: null },
                    math: { 
                        easy: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        medium: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        hard: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        overall: { gamesPlayed: 0, highScore: 0, totalTime: 0, accuracy: 0, correct: 0, total: 0, lastPlayed: null }
                    },
                    simon: {
                        easy: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        medium: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        hard: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        expert: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        overall: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [], lastPlayed: null }
                    },
                    global: { totalGames: 0, totalTime: 0, currentStreak: 0, bestStreak: 0, lastActivity: null, sessionStart: Date.now() }
                };
            }

            loadAchievements() {
                const saved = localStorage.getItem('miniGameAchievements');
                return saved ? JSON.parse(saved) : {};
            }

            saveStats() {
                localStorage.setItem('miniGameStats', JSON.stringify(this.data));
                localStorage.setItem('miniGameAchievements', JSON.stringify(this.achievements));
            }

            updateGame(game, updates, difficulty = null) {
                // Update difficulty-specific stats if applicable
                if (difficulty && this.data[game][difficulty]) {
                    Object.assign(this.data[game][difficulty], updates.difficulty || {});
                }
                
                // Update overall game stats
                if (this.data[game].overall) {
                    Object.assign(this.data[game].overall, updates.overall || updates);
                    this.data[game].overall.lastPlayed = Date.now();
                } else {
                    Object.assign(this.data[game], updates);
                    this.data[game].lastPlayed = Date.now();
                }
                
                this.data.global.totalGames++;
                this.data.global.lastActivity = Date.now();
                
                // Update total time more accurately
                if (updates.timePlayed || updates.totalTime) {
                    const timeToAdd = updates.timePlayed || updates.totalTime || 0;
                    this.data.global.totalTime += timeToAdd;
                }
                
                this.saveStats();
                this.checkAchievements();
                this.updateGlobalStats();
            }

            updateGlobalStats() {
                // Update global statistics
                document.getElementById('total-games').textContent = this.data.global.totalGames;
                
                const totalMinutes = Math.floor(this.data.global.totalTime / 60000);
                document.getElementById('total-time').textContent = totalMinutes + 'm';
                
                document.getElementById('achievements-count').textContent = Object.keys(this.achievements).length;
                document.getElementById('current-streak').textContent = this.data.global.currentStreak;
            }

            checkAchievements() {
                const achievements = [
                    { id: 'first_game', name: 'First Steps', desc: 'Play your first game', icon: '🌟', 
                      check: () => this.data.global.totalGames >= 1 },
                    { id: 'game_master', name: 'Game Master', desc: 'Play 100 games', icon: '🎮', 
                      check: () => this.data.global.totalGames >= 100 },
                    { id: 'snake_master', name: 'Snake Master', desc: 'Score 200+ in Snake', icon: '🐍', 
                      check: () => (this.data.snake.overall?.highScore || 0) >= 200 },
                    { id: 'memory_genius', name: 'Memory Genius', desc: 'Complete Memory in 20 moves', icon: '🧠', 
                      check: () => this.data.memory.overall?.bestMoves && this.data.memory.overall.bestMoves <= 20 },
                    { id: 'lightning_fast', name: 'Lightning Fast', desc: 'React in under 200ms', icon: '⚡', 
                      check: () => this.data.reaction.overall?.bestTime && this.data.reaction.overall.bestTime < 200 },
                    { id: 'lucky_guesser', name: 'Lucky Guesser', desc: 'Guess number in 3 tries', icon: '🍀', 
                      check: () => this.data.guess.overall?.bestAttempts && this.data.guess.overall.bestAttempts <= 3 },
                    { id: 'typing_speed', name: 'Speed Demon', desc: 'Type 80+ WPM', icon: '⌨️', 
                      check: () => (this.data.typing.overall?.bestWPM || 0) >= 80 },
                    { id: 'color_streak', name: 'Color Expert', desc: 'Get 25 color matches in a row', icon: '🎨', 
                      check: () => this.data.color.bestStreak >= 25 },
                    { id: 'math_wizard', name: 'Math Wizard', desc: 'Score 50+ in Math Quiz', icon: '🧮', 
                      check: () => (this.data.math.overall?.highScore || 0) >= 50 },
                    { id: 'simon_master', name: 'Simon Master', desc: 'Reach level 15 in Simon', icon: '🎵', 
                      check: () => this.data.simon.highLevel >= 15 },
                    { id: 'perfectionist', name: 'Perfectionist', desc: '100% accuracy in any typing test', icon: '💯', 
                      check: () => (this.data.typing.overall?.bestAccuracy || 0) >= 100 },
                    { id: 'time_master', name: 'Time Master', desc: 'Play for 2+ hours total', icon: '⏰', 
                      check: () => this.data.global.totalTime >= 7200000 },
                    { id: 'streak_master', name: 'Streak Master', desc: 'Win 10 games in a row', icon: '🔥', 
                      check: () => this.data.global.bestStreak >= 10 },
                    { id: 'all_rounder', name: 'All-Rounder', desc: 'Play every game at least once', icon: '🌟', 
                      check: () => Object.keys(this.data).filter(k => k !== 'global').every(game => (this.data[game].overall?.gamesPlayed || this.data[game].gamesPlayed || 0) > 0) },
                    { id: 'dedicated', name: 'Dedicated Player', desc: 'Play games on 7 different days', icon: '📅', 
                      check: () => this.getDaysPlayed() >= 7 }
                ];

                achievements.forEach(achievement => {
                    if (!this.achievements[achievement.id] && achievement.check()) {
                        this.achievements[achievement.id] = {
                            ...achievement,
                            unlockedAt: Date.now()
                        };
                        this.showAchievement(achievement);
                    }
                });

                this.updateAchievementsDisplay();
            }

            getDaysPlayed() {
                const days = new Set();
                Object.keys(this.data).forEach(game => {
                    if (game !== 'global') {
                        const lastPlayed = this.data[game].overall?.lastPlayed || this.data[game].lastPlayed;
                        if (lastPlayed) {
                            const day = new Date(lastPlayed).toDateString();
                            days.add(day);
                        }
                    }
                });
                return days.size;
            }

            showAchievement(achievement) {
                // Create achievement notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(45deg, #4CAF50, #45a049);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    z-index: 1000;
                    animation: slideIn 0.5s ease-out;
                    max-width: 300px;
                `;
                notification.innerHTML = `
                    <div style="font-size: 2rem; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Achievement Unlocked!</div>
                    <div style="font-size: 1.1rem; margin-bottom: 5px;">${achievement.name}</div>
                    <div style="opacity: 0.9;">${achievement.desc}</div>
                `;

                document.body.appendChild(notification);
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);

                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideIn 0.5s ease-out reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);

                // Play achievement sound
                this.playAchievementSound();
            }

            playAchievementSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            updateAchievementsDisplay() {
                const container = document.getElementById('achievements-display');
                if (!container) return;

                const allAchievements = [
                    { id: 'first_game', name: 'First Steps', desc: 'Play your first game', icon: '🌟' },
                    { id: 'game_master', name: 'Game Master', desc: 'Play 100 games', icon: '🎮' },
                    { id: 'snake_master', name: 'Snake Master', desc: 'Score 200+ in Snake', icon: '🐍' },
                    { id: 'memory_genius', name: 'Memory Genius', desc: 'Complete Memory in 20 moves', icon: '🧠' },
                    { id: 'lightning_fast', name: 'Lightning Fast', desc: 'React in under 200ms', icon: '⚡' },
                    { id: 'lucky_guesser', name: 'Lucky Guesser', desc: 'Guess number in 3 tries', icon: '🍀' },
                    { id: 'typing_speed', name: 'Speed Demon', desc: 'Type 80+ WPM', icon: '⌨️' },
                    { id: 'color_streak', name: 'Color Expert', desc: 'Get 25 color matches in a row', icon: '🎨' },
                    { id: 'math_wizard', name: 'Math Wizard', desc: 'Score 50+ in Math Quiz', icon: '🧮' },
                    { id: 'simon_master', name: 'Simon Master', desc: 'Reach level 15 in Simon', icon: '🎵' },
                    { id: 'perfectionist', name: 'Perfectionist', desc: '100% accuracy in typing', icon: '💯' },
                    { id: 'time_master', name: 'Time Master', desc: 'Play for 2+ hours total', icon: '⏰' },
                    { id: 'streak_master', name: 'Streak Master', desc: 'Win 10 games in a row', icon: '🔥' },
                    { id: 'all_rounder', name: 'All-Rounder', desc: 'Play every game', icon: '🌟' },
                    { id: 'dedicated', name: 'Dedicated Player', desc: 'Play on 7 different days', icon: '📅' }
                ];

                container.innerHTML = allAchievements.map(achievement => {
                    const unlocked = this.achievements[achievement.id];
                    return `
                        <div class="achievement ${unlocked ? 'unlocked' : ''}">
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                            <div style="opacity: 0.8; font-size: 0.9rem;">${achievement.desc}</div>
                            ${unlocked ? `<div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">Unlocked: ${new Date(unlocked.unlockedAt).toLocaleDateString()}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            exportStats() {
                const data = {
                    stats: this.data,
                    achievements: this.achievements,
                    exportDate: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `minigames-stats-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearStats() {
                if (confirm('Are you sure you want to clear all statistics and achievements? This cannot be undone.')) {
                    localStorage.removeItem('miniGameStats');
                    localStorage.removeItem('miniGameAchievements');
                    this.data = this.getDefaultStats();
                    this.achievements = {};
                    this.updateGlobalStats();
                    this.updateAchievementsDisplay();
                    this.displayStats();
                }
            }

            displayStats() {
                const container = document.getElementById('stats-content');
                if (!container) return;

                const games = ['snake', 'memory', 'reaction', 'guess', 'typing', 'color', 'math', 'simon'];
                const gameNames = {
                    snake: '🐍 Snake',
                    memory: '🧠 Memory Match',
                    reaction: '⚡ Reaction Time',
                    guess: '🔢 Number Guess',
                    typing: '⌨️ Typing Speed',
                    color: '🎨 Color Match',
                    math: '➕ Math Quiz',
                    simon: '🎵 Simon Says'
                };

                container.innerHTML = `
                    <div id="stats-overview">
                        <div class="stats-grid">
                            ${games.map(game => {
                                const stats = this.data[game];
                                const overall = stats.overall || stats;
                                const timePlayed = Math.floor((overall.totalTime || 0) / 60000);
                                return `
                                    <div class="stat-card" onclick="gameStats.showDetailedStats('${game}')" style="cursor: pointer; transition: transform 0.2s;">
                                        <h3 style="margin-bottom: 15px;">${gameNames[game]}</h3>
                                        <div class="stat-value">${overall.gamesPlayed || 0}</div>
                                        <div class="stat-label">Games Played</div>
                                        <div style="margin-top: 10px;">
                                            ${this.getGameSpecificStats(game, stats)}
                                        </div>
                                        <div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">
                                            Time played: ${timePlayed}m
                                        </div>
                                        ${overall.lastPlayed ? `<div style="font-size: 0.8rem; opacity: 0.7;">Last played: ${new Date(overall.lastPlayed).toLocaleDateString()}</div>` : ''}
                                        <div style="margin-top: 10px; font-size: 0.8rem; color: #4CAF50;">Click for details ↗</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div id="detailed-stats" style="display: none;">
                        <button class="btn secondary" onclick="gameStats.showOverview()" style="margin-bottom: 20px;">← Back to Overview</button>
                        <div id="detailed-content"></div>
                    </div>
                `;
            }

            getGameSpecificStats(game, stats) {
                const overall = stats.overall || stats;
                switch(game) {
                    case 'snake':
                        return `High Score: ${overall.highScore || 0}`;
                    case 'memory':
                        return `Best: ${overall.bestMoves || 'N/A'} moves<br>Win Rate: ${overall.gamesPlayed ? Math.round((overall.wins / overall.gamesPlayed) * 100) : 0}%`;
                    case 'reaction':
                        return `Best: ${overall.bestTime || 'N/A'}ms<br>Average: ${overall.tests?.length ? Math.round(overall.tests.reduce((a,b) => a+b, 0) / overall.tests.length) : 'N/A'}ms`;
                    case 'guess':
                        return `Best: ${overall.bestAttempts || 'N/A'} attempts<br>Win Rate: ${overall.gamesPlayed ? Math.round((overall.wins / overall.gamesPlayed) * 100) : 0}%`;
                    case 'typing':
                        return `Best: ${overall.bestWPM || 0} WPM<br>Best Accuracy: ${overall.bestAccuracy || 0}%`;
                    case 'color':
                        return `High Score: ${overall.highScore || 0}<br>Best Streak: ${overall.bestStreak || 0}<br>Accuracy: ${overall.total ? Math.round((overall.correct / overall.total) * 100) : 0}%`;
                    case 'math':
                        return `High Score: ${overall.highScore || 0}<br>Accuracy: ${overall.total ? Math.round((overall.correct / overall.total) * 100) : 0}%`;
                    case 'simon':
                        return `Best Level: ${overall.highLevel || 0}<br>Average: ${overall.levels?.length ? Math.round(overall.levels.reduce((a,b) => a+b, 0) / overall.levels.length) : 0}`;
                    default:
                        return '';
                }
            }

            showDetailedStats(game) {
                document.getElementById('stats-overview').style.display = 'none';
                document.getElementById('detailed-stats').style.display = 'block';
                
                const stats = this.data[game];
                const gameNames = {
                    snake: '🐍 Snake',
                    memory: '🧠 Memory Match',
                    reaction: '⚡ Reaction Time',
                    guess: '🔢 Number Guess',
                    typing: '⌨️ Typing Speed',
                    color: '🎨 Color Match',
                    math: '➕ Math Quiz',
                    simon: '🎵 Simon Says'
                };
                
                let content = `<h2>${gameNames[game]} - Detailed Stats</h2>`;
                
                if (stats.overall) {
                    // Game with difficulty levels
                    content += this.generateDetailedStatsForGame(game, stats);
                } else {
                    // Game without difficulty levels
                    content += this.generateBasicStatsForGame(game, stats);
                }
                
                document.getElementById('detailed-content').innerHTML = content;
            }

            generateDetailedStatsForGame(game, stats) {
                let content = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Overall Stats</h3>
                            ${this.generateStatsTable(stats.overall)}
                        </div>`;
                
                Object.keys(stats).forEach(difficulty => {
                    if (difficulty !== 'overall') {
                        const difficultyName = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                        content += `
                            <div class="stat-card">
                                <h3>${difficultyName} Difficulty</h3>
                                ${this.generateStatsTable(stats[difficulty], difficulty)}
                            </div>`;
                    }
                });
                
                content += `</div>`;
                return content;
            }

            generateBasicStatsForGame(game, stats) {
                return `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Game Stats</h3>
                            ${this.generateStatsTable(stats)}
                        </div>
                    </div>`;
            }

            generateStatsTable(stats, difficulty = null) {
                let table = '<table style="width: 100%; border-collapse: collapse;">';
                
                Object.keys(stats).forEach(key => {
                    if (key === 'tests' || key === 'levels') return; // Skip arrays for now
                    
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    let value = stats[key];
                    
                    if (key === 'totalTime' && value) {
                        value = `${Math.floor(value / 60000)}m ${Math.floor((value % 60000) / 1000)}s`;
                    } else if (key === 'lastPlayed' && value) {
                        value = new Date(value).toLocaleString();
                    } else if (key === 'winRate' || key === 'accuracy') {
                        value = value ? `${Math.round(value)}%` : '0%';
                    }
                    
                    table += `
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 8px; opacity: 0.8;">${label}:</td>
                            <td style="padding: 8px; font-weight: bold; color: #4CAF50;">${value || 'N/A'}</td>
                        </tr>`;
                });
                
                table += '</table>';
                
                // Add performance graph if we have historical data
                if (stats.tests && stats.tests.length > 1) {
                    table += this.generatePerformanceGraph(stats.tests, difficulty);
                } else if (stats.levels && stats.levels.length > 1) {
                    table += this.generatePerformanceGraph(stats.levels, difficulty, 'Level');
                }
                
                return table;
            }

            generatePerformanceGraph(data, difficulty = null, label = 'Performance') {
                const canvasId = `chart-${difficulty || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
                
                // Prepare data for chart
                const chartData = Array.isArray(data[0]) ? data.map(d => d.wpm || d.accuracy || d) : data;
                const maxValue = Math.max(...chartData);
                const minValue = Math.min(...chartData);
                
                setTimeout(() => this.drawChart(canvasId, chartData, label), 100);
                
                return `
                    <div style="margin-top: 15px;">
                        <h4 style="margin-bottom: 10px;">📈 ${label} Over Time</h4>
                        <canvas id="${canvasId}" width="300" height="150" style="background: rgba(0,0,0,0.1); border-radius: 8px; width: 100%; max-width: 300px; height: auto;"></canvas>
                        <div style="text-align: center; font-size: 0.8rem; opacity: 0.7; margin-top: 5px;">
                            Last ${chartData.length} games | Range: ${minValue} - ${maxValue}
                        </div>
                    </div>
                `;
            }

            drawChart(canvasId, data, label) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 30;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;
                
                ctx.clearRect(0, 0, width, height);
                
                // Set colors
                ctx.strokeStyle = '#4CAF50';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
                ctx.lineWidth = 2;
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                
                if (data.length === 0) return;
                
                const maxValue = Math.max(...data);
                const minValue = Math.min(...data);
                const range = maxValue - minValue || 1;
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (graphHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // Draw the chart line
                ctx.strokeStyle = '#4CAF50';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const stepX = graphWidth / (data.length - 1);
                
                for (let i = 0; i < data.length; i++) {
                    const x = padding + stepX * i;
                    const normalizedValue = range > 0 ? (data[i] - minValue) / range : 0.5;
                    const y = padding + graphHeight - (normalizedValue * graphHeight);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Fill area under curve
                ctx.lineTo(padding + stepX * (data.length - 1), padding + graphHeight);
                ctx.lineTo(padding, padding + graphHeight);
                ctx.closePath();
                ctx.fill();
                
                // Draw data points
                ctx.fillStyle = '#4CAF50';
                for (let i = 0; i < data.length; i++) {
                    const x = padding + stepX * i;
                    const normalizedValue = range > 0 ? (data[i] - minValue) / range : 0.5;
                    const y = padding + graphHeight - (normalizedValue * graphHeight);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.textAlign = 'center';
                ctx.fillText(minValue.toString(), padding, height - 10);
                ctx.fillText(maxValue.toString(), padding, 20);
            }

            showOverview() {
                document.getElementById('detailed-stats').style.display = 'none';
                document.getElementById('stats-overview').style.display = 'block';
            }
        }

        // Performance Analytics System
        class PerformanceAnalytics {
            constructor() {
                this.sessionData = {
                    startTime: Date.now(),
                    gamesPlayed: 0,
                    totalScore: 0,
                    averageScore: 0,
                    streak: 0,
                    bestStreak: 0,
                    gamesSinceLastBest: 0,
                    skillTrend: 'stable', // improving, declining, stable
                    performanceRating: 1000, // ELO-style rating
                    dailyGoals: { target: 10, completed: 0 },
                    weeklyStats: this.loadWeeklyStats()
                };
                this.liveMetrics = {
                    currentWPM: 0,
                    currentAccuracy: 100,
                    reactionTimes: [],
                    gameIntensity: 0,
                    focusLevel: 100
                };
                this.charts = {};
                this.startSession();
            }

            startSession() {
                const today = new Date().toDateString();
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                if (!sessions[today]) {
                    sessions[today] = { gamesPlayed: 0, timeSpent: 0, achievements: 0 };
                }
                localStorage.setItem('gameSessions', JSON.stringify(sessions));
            }

            updateLiveMetric(metric, value) {
                this.liveMetrics[metric] = value;
                this.broadcastMetricUpdate(metric, value);
            }

            broadcastMetricUpdate(metric, value) {
                const event = new CustomEvent('liveMetricUpdate', {
                    detail: { metric, value, timestamp: Date.now() }
                });
                document.dispatchEvent(event);
            }

            trackGameCompletion(game, difficulty, score, won = true) {
                this.sessionData.gamesPlayed++;
                this.sessionData.totalScore += score;
                this.sessionData.averageScore = this.sessionData.totalScore / this.sessionData.gamesPlayed;
                
                if (won) {
                    this.sessionData.streak++;
                    this.sessionData.bestStreak = Math.max(this.sessionData.bestStreak, this.sessionData.streak);
                    this.sessionData.gamesSinceLastBest = 0;
                } else {
                    this.sessionData.streak = 0;
                    this.sessionData.gamesSinceLastBest++;
                }

                this.updatePerformanceRating(game, score, won);
                this.updateDailyStats();
                this.analyzeSkillTrend();
            }

            updatePerformanceRating(game, score, won) {
                const baseChange = won ? 25 : -15;
                const scoreMultiplier = Math.min(score / 100, 2); // Cap at 2x
                const streakBonus = Math.min(this.sessionData.streak * 2, 20);
                
                const change = Math.round(baseChange * scoreMultiplier + streakBonus);
                this.sessionData.performanceRating = Math.max(100, this.sessionData.performanceRating + change);
            }

            analyzeSkillTrend() {
                const recentGames = Math.min(this.sessionData.gamesPlayed, 10);
                if (recentGames < 5) {
                    this.sessionData.skillTrend = 'stable';
                    return;
                }

                // Analyze last 10 games vs previous 10
                const currentAvg = this.sessionData.averageScore;
                const improvementThreshold = 0.1;
                
                if (this.sessionData.streak >= 3) {
                    this.sessionData.skillTrend = 'improving';
                } else if (this.sessionData.gamesSinceLastBest > 5) {
                    this.sessionData.skillTrend = 'declining';
                } else {
                    this.sessionData.skillTrend = 'stable';
                }
            }

            updateDailyStats() {
                const today = new Date().toDateString();
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                if (sessions[today]) {
                    sessions[today].gamesPlayed++;
                    this.sessionData.dailyGoals.completed = sessions[today].gamesPlayed;
                }
                localStorage.setItem('gameSessions', JSON.stringify(sessions));
            }

            loadWeeklyStats() {
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                const weekAgo = new Date();
                weekAgo.setDate(weekAgo.getDate() - 7);
                
                let weeklyGames = 0;
                let weeklyTime = 0;
                
                Object.entries(sessions).forEach(([date, data]) => {
                    const sessionDate = new Date(date);
                    if (sessionDate >= weekAgo) {
                        weeklyGames += data.gamesPlayed || 0;
                        weeklyTime += data.timeSpent || 0;
                    }
                });

                return { gamesPlayed: weeklyGames, timeSpent: weeklyTime };
            }

            getSessionSummary() {
                const sessionTime = (Date.now() - this.sessionData.startTime) / 1000 / 60;
                return {
                    ...this.sessionData,
                    sessionDuration: sessionTime,
                    gamesPerMinute: sessionTime > 0 ? this.sessionData.gamesPlayed / sessionTime : 0,
                    performanceGrade: this.getPerformanceGrade()
                };
            }

            getPerformanceGrade() {
                const rating = this.sessionData.performanceRating;
                if (rating >= 1400) return 'S+';
                if (rating >= 1200) return 'S';
                if (rating >= 1100) return 'A+';
                if (rating >= 1000) return 'A';
                if (rating >= 900) return 'B+';
                if (rating >= 800) return 'B';
                if (rating >= 700) return 'C+';
                return 'C';
            }
        }

        // Initialize analytics and statistics
        const performanceAnalytics = new PerformanceAnalytics();
        const gameStats = new GameStats();

        // Game Modal System
        class GameModal {
            constructor() {
                this.currentGame = '';
                this.currentGameInstance = null;
            }

            show(title, score, gameType, gameInstance, difficulty = 'medium') {
                this.currentGame = gameType;
                this.currentGameInstance = gameInstance;
                this.currentDifficulty = difficulty;
                
                document.getElementById('modal-title').textContent = title;
                
                // Get high scores for this specific game mode and difficulty
                const highScores = this.getHighScores(gameType, difficulty);
                const sessionStats = performanceAnalytics.getSessionSummary();
                
                const enhancedScore = `
                    ${score}
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px; font-size: 0.9rem;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left;">
                            <div>
                                <strong style="color: #FFD700;">🏆 ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} High Scores</strong><br>
                                ${highScores.slice(0, 3).map((hs, i) => `${i+1}. ${hs}`).join('<br>')}
                            </div>
                            <div>
                                <strong style="color: #4CAF50;">📊 Session Stats</strong><br>
                                Performance: ${sessionStats.performanceGrade} (${sessionStats.performanceRating})<br>
                                Streak: ${sessionStats.streak} games<br>
                                Trend: ${sessionStats.skillTrend === 'improving' ? '📈' : sessionStats.skillTrend === 'declining' ? '📉' : '➡️'} ${sessionStats.skillTrend}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">
                        Press Enter to play again, Escape to return to menu
                    </div>
                `;
                
                document.getElementById('modal-score').innerHTML = enhancedScore;
                document.getElementById('game-modal').style.display = 'block';
                
                // Add keyboard listener
                this.addKeyboardListener();
                
                // Track completion in analytics
                const gameScore = this.extractScoreFromString(score);
                performanceAnalytics.trackGameCompletion(gameType, difficulty, gameScore, !title.includes('Over') && !title.includes('Up'));
                
                // Animate in
                setTimeout(() => {
                    document.querySelector('.modal-content').style.animation = 'modalSlideIn 0.3s ease-out';
                }, 50);
            }

            getHighScores(gameType, difficulty) {
                const stats = gameStats.data[gameType];
                if (!stats) return ['No scores yet', '', ''];
                
                let scores = [];
                
                // Get multiple scores for proper leaderboard
                switch(gameType) {
                    case 'snake':
                        // Get scores from different modes/difficulties
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highScore > 0) {
                                let label = key.includes('_') ? key.replace('_', ' ') : key;
                                scores.push({ score: stats[key].highScore, label: label });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map((item, i) => `${item.score} (${item.label})`);
                        
                    case 'typing':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestWPM > 0) {
                                let label = key.includes('_') ? key.replace('_', ' ') : key;
                                scores.push({ score: stats[key].bestWPM, label: label });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map((item, i) => `${item.score} WPM (${item.label})`);
                        
                    case 'math':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highScore > 0) {
                                scores.push({ score: stats[key].highScore, label: key });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map(item => `${item.score} (${item.label})`);
                        
                    case 'memory':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestMoves > 0) {
                                scores.push({ score: stats[key].bestMoves, label: key });
                            }
                        });
                        scores.sort((a, b) => a.score - b.score); // Lower is better
                        return scores.slice(0, 3).map(item => `${item.score} moves (${item.label})`);
                        
                    case 'simon':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highLevel > 0) {
                                scores.push({ score: stats[key].highLevel, label: key });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map(item => `Level ${item.score} (${item.label})`);
                        
                    case 'reaction':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestTime > 0) {
                                scores.push({ score: stats[key].bestTime, label: key });
                            }
                        });
                        scores.sort((a, b) => a.score - b.score); // Lower is better
                        return scores.slice(0, 3).map(item => `${item.score}ms (${item.label})`);
                        
                    case 'guess':
                        const guessStats = stats.overall || stats;
                        return [`${guessStats.bestAttempts || 'N/A'} attempts`, '', ''];
                        
                    case 'color':
                        return [`${stats.highScore || 0} points`, `${stats.bestStreak || 0} streak`, ''];
                }
                
                // Fallback
                return ['No scores yet', '', ''];
            }

            extractScoreFromString(scoreString) {
                const numbers = scoreString.match(/\d+/g);
                return numbers ? parseInt(numbers[0]) : 0;
            }

            addKeyboardListener() {
                this.keyboardHandler = (e) => {
                    if (document.getElementById('game-modal').style.display === 'block') {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.restartGame();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.goToMenu();
                        }
                    }
                };
                
                document.addEventListener('keydown', this.keyboardHandler);
            }

            removeKeyboardListener() {
                if (this.keyboardHandler) {
                    document.removeEventListener('keydown', this.keyboardHandler);
                    this.keyboardHandler = null;
                }
            }

            hide() {
                document.getElementById('game-modal').style.display = 'none';
                this.removeKeyboardListener();
            }

            restartGame() {
                this.hide();
                // Call the appropriate start function based on current game
                switch(this.currentGame) {
                    case 'snake': startSnake(); break;
                    case 'memory': startMemory(); break;
                    case 'reaction': startReaction(); break;
                    case 'guess': startGuessing(); break;
                    case 'typing': startTyping(); break;
                    case 'color': startColorMatch(); break;
                    case 'math': startMath(); break;
                    case 'simon': startSimon(); break;
                }
            }

            goToMenu() {
                this.hide();
                showScreen('menu');
            }

            changeDifficulty() {
                this.hide();
                // Show the appropriate game screen so user can change settings
                showScreen(this.currentGame);
            }
        }

        const gameModal = new GameModal();

        // Navigation and Screen Management
        function showScreen(screenId) {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(screenId + '-screen').classList.add('active');
            document.querySelector(`[onclick="showScreen('${screenId}')"]`).classList.add('active');

            // Load screen-specific content
            if (screenId === 'stats') {
                gameStats.displayStats();
                gameStats.updateAchievementsDisplay();
            }
        }

        function showSessionStats() {
            const panel = document.getElementById('session-analytics');
            const isVisible = panel.style.display !== 'none';
            
            if (isVisible) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            updateSessionAnalytics();
        }

        function updateSessionAnalytics() {
            const sessionSummary = performanceAnalytics.getSessionSummary();
            const liveMetrics = performanceAnalytics.liveMetrics;
            
            // Current Session Stats
            document.getElementById('current-session-stats').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                    <div><strong>Games Played:</strong> ${sessionSummary.gamesPlayed}</div>
                    <div><strong>Session Time:</strong> ${Math.round(sessionSummary.sessionDuration)}m</div>
                    <div><strong>Performance Grade:</strong> <span style="color: #4CAF50; font-weight: bold;">${sessionSummary.performanceGrade}</span></div>
                    <div><strong>Rating:</strong> ${sessionSummary.performanceRating}</div>
                    <div><strong>Current Streak:</strong> ${sessionSummary.streak}</div>
                    <div><strong>Best Streak:</strong> ${sessionSummary.bestStreak}</div>
                    <div><strong>Avg Score:</strong> ${Math.round(sessionSummary.averageScore)}</div>
                    <div><strong>Skill Trend:</strong> ${sessionSummary.skillTrend === 'improving' ? '📈' : sessionSummary.skillTrend === 'declining' ? '📉' : '➡️'} ${sessionSummary.skillTrend}</div>
                </div>
            `;
            
            // Performance Trends
            document.getElementById('performance-trends').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div style="margin-bottom: 10px;"><strong>Games per minute:</strong> ${sessionSummary.gamesPerMinute.toFixed(2)}</div>
                    <div style="margin-bottom: 10px;"><strong>Focus Level:</strong> <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 10px;"><div style="width: ${liveMetrics.focusLevel}%; background: #4CAF50; height: 100%; border-radius: 10px;"></div></div></div>
                    <div><strong>Game Intensity:</strong> <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 10px;"><div style="width: ${liveMetrics.gameIntensity}%; background: #FF9800; height: 100%; border-radius: 10px;"></div></div></div>
                </div>
            `;
            
            // Daily Progress
            const dailyGoals = sessionSummary.dailyGoals;
            const dailyProgress = Math.min((dailyGoals.completed / dailyGoals.target) * 100, 100);
            document.getElementById('daily-progress').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div style="margin-bottom: 10px;"><strong>Daily Goal:</strong> ${dailyGoals.completed}/${dailyGoals.target} games</div>
                    <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 15px; margin-bottom: 10px;">
                        <div style="width: ${dailyProgress}%; background: linear-gradient(45deg, #4CAF50, #8BC34A); height: 100%; border-radius: 10px;"></div>
                    </div>
                    <div><strong>Weekly Games:</strong> ${sessionSummary.weeklyStats.gamesPlayed}</div>
                    <div><strong>Weekly Time:</strong> ${Math.round(sessionSummary.weeklyStats.timeSpent / 60000)}m</div>
                </div>
            `;
            
            // Live Metrics
            document.getElementById('live-metrics').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div><strong>Live WPM:</strong> ${liveMetrics.currentWPM}</div>
                    <div><strong>Live Accuracy:</strong> ${liveMetrics.currentAccuracy}%</div>
                    <div><strong>Recent Reactions:</strong> ${liveMetrics.reactionTimes.slice(-3).join('ms, ')}${liveMetrics.reactionTimes.length > 0 ? 'ms' : 'None'}</div>
                </div>
            `;
            
            // Draw performance rating chart
            drawPerformanceChart();
        }

        function drawPerformanceChart() {
            const canvas = document.getElementById('rating-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Mock data - in real implementation, this would come from stored rating history
            const ratingHistory = [1000, 1025, 1015, 1040, 1035, 1050, 1045, 1060, 1055, 1070];
            const currentRating = performanceAnalytics.sessionData.performanceRating;
            ratingHistory.push(currentRating);
            
            if (ratingHistory.length < 2) return;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 50, y);
                ctx.stroke();
            }
            
            // Draw rating line
            const minRating = Math.min(...ratingHistory) - 50;
            const maxRating = Math.max(...ratingHistory) + 50;
            const range = maxRating - minRating;
            
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            ratingHistory.forEach((rating, index) => {
                const x = 50 + ((width - 100) / (ratingHistory.length - 1)) * index;
                const y = height - 50 - ((rating - minRating) / range) * (height - 100);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#4CAF50';
            ratingHistory.forEach((rating, index) => {
                const x = 50 + ((width - 100) / (ratingHistory.length - 1)) * index;
                const y = height - 50 - ((rating - minRating) / range) * (height - 100);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${Math.round(maxRating)}`, 10, 20);
            ctx.fillText(`${Math.round(minRating)}`, 10, height - 10);
            ctx.textAlign = 'center';
            ctx.fillText(`Current: ${currentRating}`, width / 2, height - 10);
        }

        function toggleLeaderboards() {
            const section = document.getElementById('leaderboards-section');
            const isVisible = section.style.display !== 'none';
            
            if (isVisible) {
                section.style.display = 'none';
            } else {
                section.style.display = 'block';
                generateLeaderboards();
            }
        }

        function generateLeaderboards() {
            const content = document.getElementById('leaderboards-content');
            const stats = gameStats.data;
            
            let leaderboardHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">';
            
            // Snake Leaderboards
            leaderboardHTML += generateGameLeaderboard('Snake', stats.snake, 'highScore', '🐍');
            
            // Memory Leaderboards
            leaderboardHTML += generateGameLeaderboard('Memory', stats.memory, 'bestMoves', '🧠', true);
            
            // Typing Leaderboards
            leaderboardHTML += generateGameLeaderboard('Typing', stats.typing, 'bestWPM', '⌨️');
            
            // Math Leaderboards
            leaderboardHTML += generateGameLeaderboard('Math', stats.math, 'highScore', '➕');
            
            // Simon Leaderboards
            leaderboardHTML += generateGameLeaderboard('Simon', stats.simon, 'highLevel', '🎵');
            
            // Reaction Time Leaderboards
            leaderboardHTML += generateGameLeaderboard('Reaction', stats.reaction, 'bestTime', '⚡', true);
            
            leaderboardHTML += '</div>';
            content.innerHTML = leaderboardHTML;
        }

        function generateGameLeaderboard(gameName, gameStats, statKey, emoji, lowerIsBetter = false) {
            if (!gameStats) return '';
            
            let html = `<div class="stat-card"><h4>${emoji} ${gameName}</h4><div style="font-size: 0.9rem;">`;
            let hasAnyScores = false;
            
            // Group by difficulty/mode combinations
            Object.keys(gameStats).forEach(key => {
                if (key === 'overall') return;
                
                const stats = gameStats[key];
                if (!stats || !stats[statKey] || stats[statKey] === 0) return;
                
                hasAnyScores = true;
                let displayKey = key;
                
                if (key.includes('_')) {
                    const parts = key.split('_');
                    displayKey = `${parts[0].charAt(0).toUpperCase() + parts[0].slice(1)} (${parts[1].charAt(0).toUpperCase() + parts[1].slice(1)})`;
                } else {
                    displayKey = key.charAt(0).toUpperCase() + key.slice(1);
                }
                
                let scoreDisplay = stats[statKey];
                if (statKey === 'bestTime') scoreDisplay = `${stats[statKey]}ms`;
                else if (statKey === 'bestWPM') scoreDisplay = `${stats[statKey]} WPM`;
                else if (statKey === 'bestMoves') scoreDisplay = `${stats[statKey]} moves`;
                else if (statKey === 'highLevel') scoreDisplay = `Level ${stats[statKey]}`;
                
                // For now showing best single score per mode/difficulty
                // In future, could extend to track multiple scores per mode
                html += `
                    <div style="margin-bottom: 10px;">
                        <div style="font-weight: bold; color: #4CAF50; margin-bottom: 3px;">${displayKey}</div>
                        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
                            <span>🥇 Best Score</span>
                            <span><strong>${scoreDisplay}</strong></span>
                        </div>
                        <div style="font-size: 0.8rem; color: #888;">Games played: ${stats.gamesPlayed || 0}</div>
                    </div>
                `;
            });
            
            if (!hasAnyScores) {
                html += '<div>No scores recorded yet</div>';
            }
            
            html += '</div></div>';
            return html;
        }

        // Export and clear functions
        function exportStats() {
            gameStats.exportStats();
        }

        function clearStats() {
            gameStats.clearStats();
        }

        // Game 1: Snake Game
        class SnakeGame {
            constructor() {
                this.canvas = document.getElementById('snake-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;
                this.reset();
                this.setupControls();
            }

            reset() {
                this.snake = [{x: 10, y: 10}];
                this.dx = 0;
                this.dy = 0;
                this.apple = {x: 15, y: 15};
                this.score = 0;
                this.gameRunning = false;
                this.gamePaused = false;
                this.startTime = null;
                this.speed = 100; // Starting speed (ms between moves)
                this.mode = 'classic';
                this.updateScore();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.gamePaused) return;

                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            if (this.dy === 0) { this.dx = 0; this.dy = -1; }
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            if (this.dy === 0) { this.dx = 0; this.dy = 1; }
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            if (this.dx === 0) { this.dx = -1; this.dy = 0; }
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            if (this.dx === 0) { this.dx = 1; this.dy = 0; }
                            break;
                    }
                });
            }

            start() {
                if (this.gameRunning) {
                    // Reset the game if already running
                    this.gameRunning = false;
                    document.getElementById('snake-start').disabled = false;
                    document.getElementById('snake-pause').disabled = true;
                }
                this.reset(); // Reset game state
                this.mode = document.getElementById('snake-mode').value;
                this.difficulty = document.getElementById('snake-difficulty').value;
                
                // Set speed based on difficulty
                switch(this.difficulty) {
                    case 'easy': this.speed = 150; break;
                    case 'medium': this.speed = 100; break;
                    case 'hard': this.speed = 70; break;
                }
                
                this.gameRunning = true;
                this.gamePaused = false;
                this.startTime = Date.now();
                document.getElementById('snake-start').disabled = true;
                document.getElementById('snake-pause').disabled = false;
                this.dx = 0; // Don't move during countdown
                this.dy = 0;
                
                // Start countdown
                this.showCountdown(3, () => {
                    this.dx = 1; // Start moving right after countdown
                    this.dy = 0;
                    this.gameLoop();
                });
            }

            pause() {
                this.gamePaused = !this.gamePaused;
                document.getElementById('snake-pause').textContent = this.gamePaused ? 'Resume' : 'Pause';
                if (!this.gamePaused) this.gameLoop();
            }

            gameLoop() {
                if (!this.gameRunning || this.gamePaused) return;

                this.update();
                this.draw();

                if (this.gameRunning) {
                    setTimeout(() => this.gameLoop(), this.speed);
                }
            }

            update() {
                const head = {x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy};

                // Check wall collision
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
                    this.gameOver();
                    return;
                }

                // Check self collision
                for (let segment of this.snake) {
                    if (head.x === segment.x && head.y === segment.y) {
                        this.gameOver();
                        return;
                    }
                }

                this.snake.unshift(head);

                // Check apple collision
                if (head.x === this.apple.x && head.y === this.apple.y) {
                    this.score += 10;
                    this.updateScore();
                    this.generateApple();
                    this.playSound(523.25, 0.1); // Apple sound
                    
                    // Increase speed in accelerating mode
                    if (this.mode === 'accelerate') {
                        this.speed = Math.max(30, this.speed - 5); // Minimum 30ms, decrease by 5ms each apple
                    }
                } else {
                    this.snake.pop();
                }
            }

            generateApple() {
                do {
                    this.apple = {
                        x: Math.floor(Math.random() * this.tileCount),
                        y: Math.floor(Math.random() * this.tileCount)
                    };
                } while (this.snake.some(segment => segment.x === this.apple.x && segment.y === this.apple.y));
            }

            draw() {
                // Clear canvas completely
                this.ctx.fillStyle = 'rgba(0,0,0,1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw snake
                this.ctx.fillStyle = '#4CAF50';
                for (let segment of this.snake) {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                }

                // Draw apple
                this.ctx.fillStyle = '#f44336';
                this.ctx.beginPath();
                this.ctx.arc(
                    this.apple.x * this.gridSize + this.gridSize/2,
                    this.apple.y * this.gridSize + this.gridSize/2,
                    this.gridSize/2 - 2,
                    0,
                    2 * Math.PI
                );
                this.ctx.fill();
            }

            updateScore() {
                document.getElementById('snake-score').textContent = this.score;
            }

            gameOver() {
                this.gameRunning = false;
                document.getElementById('snake-start').disabled = false;
                document.getElementById('snake-pause').disabled = true;
                
                const timePlayed = Date.now() - this.startTime;
                const difficulty = this.difficulty || 'medium';
                const mode = this.mode || 'classic';
                const statsKey = `${difficulty}_${mode}`; // e.g., "medium_accelerate"
                
                // Initialize stats for this specific difficulty-mode combo if needed
                if (!gameStats.data.snake[statsKey]) {
                    gameStats.data.snake[statsKey] = { gamesPlayed: 0, highScore: 0, totalTime: 0 };
                }
                
                // Get current stats for difficulty-mode combo and overall
                const modeStats = gameStats.data.snake[statsKey];
                const diffStats = gameStats.data.snake[difficulty];
                const overallStats = gameStats.data.snake.overall;
                
                // Update mode-specific stats
                gameStats.data.snake[statsKey] = {
                    gamesPlayed: modeStats.gamesPlayed + 1,
                    highScore: Math.max(modeStats.highScore, this.score),
                    totalTime: modeStats.totalTime + timePlayed
                };
                
                // Update difficulty stats
                gameStats.data.snake[difficulty] = {
                    gamesPlayed: diffStats.gamesPlayed + 1,
                    highScore: Math.max(diffStats.highScore, this.score),
                    totalTime: diffStats.totalTime + timePlayed
                };
                
                // Update overall stats
                gameStats.data.snake.overall = {
                    gamesPlayed: overallStats.gamesPlayed + 1,
                    highScore: Math.max(overallStats.highScore, this.score),
                    totalTime: overallStats.totalTime + timePlayed
                };
                
                gameStats.saveStats();

                this.playSound(220, 0.3); // Game over sound
                gameModal.show('🐍 Game Over!', `Score: ${this.score}`, 'snake', this, this.difficulty);
            }

            showCountdown(count, callback) {
                if (count <= 0) {
                    // Clear countdown display and start game
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    callback();
                    return;
                }

                // Draw countdown
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.font = 'bold 72px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(count.toString(), this.canvas.width / 2, this.canvas.height / 2 + 20);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '24px Arial';
                this.ctx.fillText('Get Ready!', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.playSound(440 + count * 100, 0.2);

                setTimeout(() => {
                    this.showCountdown(count - 1, callback);
                }, 1000);
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let snakeGame;

        function startSnake() {
            if (!snakeGame) snakeGame = new SnakeGame();
            snakeGame.start();
        }

        function pauseSnake() {
            if (snakeGame) snakeGame.pause();
        }

        function resetSnake() {
            if (snakeGame) snakeGame.reset();
        }

        // Game 2: Memory Card Matching Game
        class MemoryGame {
            constructor() {
                this.cards = [];
                this.flippedCards = [];
                this.moves = 0;
                this.pairs = 0;
                this.maxPairs = 8;
                this.gameRunning = false;
                this.startTime = null;
            }

            start() {
                this.reset();
                this.generateCards();
                this.gameRunning = true;
                this.startTime = Date.now();
            }

            reset() {
                this.cards = [];
                this.flippedCards = [];
                this.moves = 0;
                this.pairs = 0;
                this.gameRunning = false;
                this.updateDisplay();
            }

            generateCards() {
                const difficulty = document.getElementById('memory-difficulty').value;
                let gridSize, symbols;

                switch(difficulty) {
                    case 'easy':
                        gridSize = { rows: 3, cols: 4 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊'];
                        this.maxPairs = 6;
                        break;
                    case 'medium':
                        gridSize = { rows: 4, cols: 4 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼'];
                        this.maxPairs = 8;
                        break;
                    case 'hard':
                        gridSize = { rows: 4, cols: 5 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐸', '🐵'];
                        this.maxPairs = 10;
                        break;
                }

                // Create pairs
                const cardSymbols = [...symbols, ...symbols].slice(0, this.maxPairs * 2);
                cardSymbols.sort(() => Math.random() - 0.5);

                this.cards = cardSymbols.map((symbol, index) => ({
                    id: index,
                    symbol: symbol,
                    flipped: false,
                    matched: false
                }));

                this.renderGrid(gridSize);
            }

            renderGrid(gridSize) {
                const grid = document.getElementById('memory-grid');
                grid.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
                
                grid.innerHTML = this.cards.map(card => 
                    `<div class="memory-card" onclick="flipCard(${card.id})" data-id="${card.id}">
                        ${card.flipped || card.matched ? card.symbol : '?'}
                    </div>`
                ).join('');
            }

            flipCard(cardId) {
                if (!this.gameRunning || this.flippedCards.length >= 2) return;

                const card = this.cards[cardId];
                if (card.flipped || card.matched) return;

                card.flipped = true;
                this.flippedCards.push(card);
                this.updateCardDisplay(cardId);

                if (this.flippedCards.length === 2) {
                    this.moves++;
                    this.updateDisplay();
                    
                    setTimeout(() => this.checkMatch(), 1000);
                }
            }

            checkMatch() {
                const [card1, card2] = this.flippedCards;

                if (card1.symbol === card2.symbol) {
                    card1.matched = true;
                    card2.matched = true;
                    this.pairs++;
                    this.playSound(659.25, 0.2); // Match sound

                    if (this.pairs === this.maxPairs) {
                        this.gameWon();
                    }
                } else {
                    card1.flipped = false;
                    card2.flipped = false;
                    this.updateCardDisplay(card1.id);
                    this.updateCardDisplay(card2.id);
                    this.playSound(220, 0.1); // No match sound
                }

                this.flippedCards = [];
                this.updateDisplay();
            }

            updateCardDisplay(cardId) {
                const cardElement = document.querySelector(`[data-id="${cardId}"]`);
                const card = this.cards[cardId];
                cardElement.textContent = card.flipped || card.matched ? card.symbol : '?';
                cardElement.classList.toggle('flipped', card.flipped || card.matched);
            }

            updateDisplay() {
                document.getElementById('memory-moves').textContent = this.moves;
                document.getElementById('memory-pairs').textContent = `${this.pairs}/${this.maxPairs}`;
            }

            gameWon() {
                this.gameRunning = false;
                const timePlayed = Date.now() - this.startTime;
                const difficulty = document.getElementById('memory-difficulty').value;
                
                const diffStats = gameStats.data.memory[difficulty];
                const overallStats = gameStats.data.memory.overall;
                
                gameStats.updateGame('memory', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestMoves: diffStats.bestMoves ? Math.min(diffStats.bestMoves, this.moves) : this.moves,
                        totalTime: diffStats.totalTime + timePlayed,
                        wins: diffStats.wins + 1
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestMoves: overallStats.bestMoves ? Math.min(overallStats.bestMoves, this.moves) : this.moves,
                        totalTime: overallStats.totalTime + timePlayed,
                        wins: overallStats.wins + 1
                    },
                    timePlayed: timePlayed
                }, difficulty);

                this.playSound(523.25, 0.5); // Victory sound
                setTimeout(() => {
                    gameModal.show('🧠 Congratulations!', `You won in ${this.moves} moves!`, 'memory', this, this.difficulty);
                }, 100);
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let memoryGame = new MemoryGame();

        function startMemory() {
            memoryGame.start();
        }

        function flipCard(cardId) {
            memoryGame.flipCard(cardId);
        }

        // Game 3: Reaction Time Test
        class ReactionGame {
            constructor() {
                this.area = document.getElementById('reaction-area');
                this.circle = document.getElementById('reaction-circle');
                this.text = document.getElementById('reaction-text');
                this.isWaiting = false;
                this.startTime = 0;
                this.timeouts = [];
                this.mode = 'area';
            }

            start() {
                if (this.isWaiting) return;
                
                this.mode = document.getElementById('reaction-mode').value;
                this.clearTimeouts();
                this.setupMode();
                this.isWaiting = true;

                const delay = Math.random() * 4000 + 1000; // 1-5 seconds
                const timeout = setTimeout(() => this.showTarget(), delay);
                this.timeouts.push(timeout);
            }

            setupMode() {
                if (this.mode === 'area') {
                    this.area.style.background = '#f44336';
                    this.text.textContent = 'Wait for GREEN...';
                    this.circle.style.display = 'none';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.tooEarly();
                    };
                    this.circle.onclick = null;
                } else {
                    this.area.style.background = '#333';
                    this.text.textContent = 'Wait for GREEN circle...';
                    this.circle.style.display = 'none';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.tooEarly();
                    };
                }
            }

            showTarget() {
                if (!this.isWaiting) return;
                
                this.startTime = performance.now();

                if (this.mode === 'area') {
                    this.area.style.background = '#4CAF50';
                    this.text.textContent = 'CLICK NOW!';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.clicked();
                    };
                } else {
                    // Position circle randomly
                    const maxX = this.area.clientWidth - 50;
                    const maxY = this.area.clientHeight - 50;
                    const x = Math.random() * maxX;
                    const y = Math.random() * maxY;
                    
                    this.circle.style.left = x + 'px';
                    this.circle.style.top = y + 'px';
                    this.circle.style.display = 'block';
                    this.text.textContent = 'CLICK THE CIRCLE!';
                    
                    this.circle.onclick = () => this.clicked();
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.missedTarget();
                    };
                }
            }

            clicked() {
                if (!this.isWaiting) return;
                
                const reactionTime = Math.round(performance.now() - this.startTime);
                this.isWaiting = false;
                
                if (this.mode === 'area') {
                    this.area.style.background = '#2196F3';
                    this.text.textContent = `${reactionTime}ms`;
                } else {
                    this.area.style.background = '#2196F3';
                    this.circle.style.display = 'none';
                    this.text.textContent = `${reactionTime}ms`;
                }
                
                this.area.onclick = null;
                this.circle.onclick = null;

                // Update stats for specific mode and overall
                const currentBest = gameStats.data.reaction[this.mode].bestTime;
                const overallBest = gameStats.data.reaction.overall.bestTime;
                const newBest = !currentBest || reactionTime < currentBest;
                const newOverallBest = !overallBest || reactionTime < overallBest;

                gameStats.updateGame('reaction', {
                    difficulty: {
                        gamesPlayed: gameStats.data.reaction[this.mode].gamesPlayed + 1,
                        bestTime: newBest ? reactionTime : currentBest,
                        totalTime: gameStats.data.reaction[this.mode].totalTime + reactionTime,
                        tests: [...gameStats.data.reaction[this.mode].tests.slice(-19), reactionTime]
                    },
                    overall: {
                        gamesPlayed: gameStats.data.reaction.overall.gamesPlayed + 1,
                        bestTime: newOverallBest ? reactionTime : overallBest,
                        totalTime: gameStats.data.reaction.overall.totalTime + reactionTime,
                        tests: [...gameStats.data.reaction.overall.tests.slice(-19), reactionTime]
                    },
                    timePlayed: reactionTime
                }, this.mode);

                document.getElementById('reaction-best').textContent = gameStats.data.reaction.overall.bestTime || 'N/A';
                document.getElementById('reaction-status').textContent = `${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} mode: ${reactionTime}ms ${newBest ? '(New Best!)' : ''}`;
                
                if (newBest) this.playSound(523.25, 0.3);
                else this.playSound(440, 0.2);
                
                // Click on status area to restart instantly
                document.getElementById('reaction-status').style.cursor = 'pointer';
                document.getElementById('reaction-status').style.padding = '10px';
                document.getElementById('reaction-status').style.border = '2px dashed #4CAF50';
                document.getElementById('reaction-status').style.borderRadius = '5px';
                document.getElementById('reaction-status').onclick = () => this.start();
            }

            missedTarget() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#FF9800';
                this.circle.style.display = 'none';
                this.text.textContent = 'Missed! Click the circle only';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'You missed the target! Click only the green circle.';
                this.playSound(220, 0.3);
            }

            tooEarly() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#FF9800';
                this.circle.style.display = 'none';
                this.text.textContent = 'Too early! Try again';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'You clicked too early! Wait for the target.';
                this.playSound(220, 0.3);
            }

            reset() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#f44336';
                this.text.textContent = 'Click to Start';
                this.circle.style.display = 'none';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'Click "Start Test" to begin';
                document.getElementById('reaction-status').style.cursor = 'default';
                document.getElementById('reaction-status').style.border = 'none';
                document.getElementById('reaction-status').onclick = null;
            }

            clearTimeouts() {
                this.timeouts.forEach(timeout => clearTimeout(timeout));
                this.timeouts = [];
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let reactionGame = new ReactionGame();

        function startReaction() {
            reactionGame.start();
        }

        function resetReaction() {
            reactionGame.reset();
        }

        // Game 4: Number Guessing Game
        class GuessGame {
            constructor() {
                this.secretNumber = 0;
                this.attempts = 0;
                this.maxNumber = 100;
                this.gameRunning = false;
                this.startTime = null;
                this.guessHistory = [];
                this.range = { min: 1, max: 100 };
            }

            start() {
                const difficulty = document.getElementById('guess-difficulty').value;
                switch(difficulty) {
                    case 'easy': this.maxNumber = 50; break;
                    case 'medium': this.maxNumber = 100; break;
                    case 'hard': this.maxNumber = 500; break;
                }

                this.secretNumber = Math.floor(Math.random() * this.maxNumber) + 1;
                this.attempts = 0;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.guessHistory = [];
                this.range = { min: 1, max: this.maxNumber };
                
                document.getElementById('guess-input').value = '';
                document.getElementById('guess-input').max = this.maxNumber;
                document.getElementById('guess-input').placeholder = `Enter number 1-${this.maxNumber}`;
                document.getElementById('guess-feedback').textContent = `I'm thinking of a number between 1 and ${this.maxNumber}`;
                document.getElementById('guess-hints').style.display = 'none';
                document.getElementById('guess-history').textContent = '';
                this.updateDisplay();
            }

            makeGuess() {
                if (!this.gameRunning) {
                    this.start();
                    return;
                }

                const input = document.getElementById('guess-input');
                const guess = parseInt(input.value);

                if (isNaN(guess) || guess < 1 || guess > this.maxNumber) {
                    document.getElementById('guess-feedback').textContent = `Please enter a valid number between 1 and ${this.maxNumber}`;
                    return;
                }

                // Check for duplicate guess
                if (this.guessHistory.includes(guess)) {
                    document.getElementById('guess-feedback').textContent = `You already guessed ${guess}! Try a different number.`;
                    this.playSound(220, 0.2);
                    return;
                }

                this.attempts++;
                this.guessHistory.push(guess);
                this.updateDisplay();

                if (guess === this.secretNumber) {
                    this.gameWon();
                } else if (guess < this.secretNumber) {
                    this.range.min = Math.max(this.range.min, guess + 1);
                    const diff = this.secretNumber - guess;
                    let feedback = `Too low! Try a higher number.`;
                    
                    if (diff <= 5) feedback += ` 🔥 Very close!`;
                    else if (diff <= 10) feedback += ` Getting warmer!`;
                    
                    document.getElementById('guess-feedback').textContent = feedback;
                    this.playSound(440, 0.1);
                } else {
                    this.range.max = Math.min(this.range.max, guess - 1);
                    const diff = guess - this.secretNumber;
                    let feedback = `Too high! Try a lower number.`;
                    
                    if (diff <= 5) feedback += ` 🔥 Very close!`;
                    else if (diff <= 10) feedback += ` Getting warmer!`;
                    
                    document.getElementById('guess-feedback').textContent = feedback;
                    this.playSound(330, 0.1);
                }

                this.updateHistory();
                this.showHints();
                input.value = '';
            }

            gameWon() {
                this.gameRunning = false;
                const timePlayed = Date.now() - this.startTime;
                const difficulty = document.getElementById('guess-difficulty').value;
                
                const diffStats = gameStats.data.guess[difficulty];
                const overallStats = gameStats.data.guess.overall;
                const diffBest = !diffStats.bestAttempts || this.attempts < diffStats.bestAttempts;
                const overallBest = !overallStats.bestAttempts || this.attempts < overallStats.bestAttempts;

                gameStats.updateGame('guess', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestAttempts: diffBest ? this.attempts : diffStats.bestAttempts,
                        totalTime: diffStats.totalTime + timePlayed,
                        wins: diffStats.wins + 1
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestAttempts: overallBest ? this.attempts : overallStats.bestAttempts,
                        totalTime: overallStats.totalTime + timePlayed,
                        wins: overallStats.wins + 1
                    },
                    timePlayed: timePlayed
                }, difficulty);

                document.getElementById('guess-feedback').textContent = `🎉 Correct! The number was ${this.secretNumber}. You got it in ${this.attempts} attempts!`;
                this.updateDisplay();
                this.playSound(523.25, 0.5);
                gameModal.show('🔢 Congratulations!', `You guessed ${this.secretNumber} in ${this.attempts} attempts!`, 'guess', this, this.difficulty);
            }

            updateDisplay() {
                document.getElementById('guess-attempts').textContent = this.attempts;
                const best = gameStats.data.guess.overall.bestAttempts;
                document.getElementById('guess-best').textContent = best || 'N/A';
            }

            updateHistory() {
                if (this.guessHistory.length === 0) return;
                
                const historyText = `Previous guesses: ${this.guessHistory.join(', ')}`;
                document.getElementById('guess-history').textContent = historyText;
            }

            showHints() {
                if (this.attempts < 3) return; // No hints for first 2 attempts
                
                const hintDiv = document.getElementById('guess-hints');
                const hintText = document.getElementById('hint-text');
                
                if (this.attempts >= 5) {
                    // Show narrow range hint after 5 attempts
                    hintText.textContent = `The number is between ${this.range.min} and ${this.range.max}`;
                    hintDiv.style.display = 'block';
                } else if (this.attempts >= 3) {
                    // Show general hint after 3 attempts
                    const isEven = this.secretNumber % 2 === 0;
                    hintText.textContent = `The number is ${isEven ? 'even' : 'odd'}`;
                    hintDiv.style.display = 'block';
                }
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let guessGame = new GuessGame();

        function startGuessing() {
            guessGame.start();
        }

        function makeGuess() {
            guessGame.makeGuess();
        }

        // Game 5: Typing Speed Test
        class TypingGame {
            constructor() {
                this.textCollections = {
                    easy: [
                        "The cat sat on the mat. Dogs run in the park. Kids play with toys. Books are on the desk. Cars drive down the road.",
                        "I like to eat pizza. The sun is bright today. We go to school every day. My friend has a red bike. Fish swim in the water.",
                        "Birds fly in the sky. The grass is green. I have a pet dog. Mom makes good food. Dad reads the news paper.",
                        "Rain falls from clouds. Snow is cold and white. Trees grow tall and strong. Flowers bloom in spring time. Summer days are hot.",
                        "I walk to the store. We buy milk and bread. The baby sleeps in the crib. My room has a big bed. Kids love to play games."
                    ],
                    medium: [
                        "The quick brown fox jumps over the lazy dog. This pangram contains every letter of the alphabet at least once. Many typing tests use this sentence because it provides a good variety of common letters and letter combinations that appear frequently in English text.",
                        "Technology has revolutionized the way we communicate, work, and live. From smartphones to artificial intelligence, innovations continue to shape our daily experiences. Digital transformation affects every industry, creating new opportunities while also presenting unique challenges that require adaptive solutions.",
                        "Climate change represents one of the most pressing challenges of our time. Rising global temperatures, changing weather patterns, and environmental degradation affect ecosystems worldwide. Sustainable practices, renewable energy adoption, and international cooperation are essential for addressing this complex issue.",
                        "Education plays a crucial role in personal development and societal progress. Learning new skills, acquiring knowledge, and developing critical thinking abilities help individuals navigate an increasingly complex world. Continuous learning throughout life has become essential for career advancement and personal fulfillment.",
                        "The internet has transformed how we access information, connect with others, and conduct business. Social media platforms enable global communication, while e-commerce has revolutionized shopping and commerce. However, these technological advances also raise important questions about privacy, security, and digital literacy."
                    ],
                    hard: [
                        "Philosophical contemplation necessitates meticulous examination of fundamental epistemological assumptions. The phenomenological investigation of consciousness requires careful differentiation between subjective experiential phenomena and objective empirical observations, particularly when analyzing the hermeneutical implications of existential authenticity.",
                        "Quantum mechanical superposition demonstrates the counterintuitive probabilistic nature of subatomic particle behavior. The Copenhagen interpretation suggests that wave function collapse occurs upon measurement, yet the many-worlds hypothesis proposes infinite parallel realities where all possible quantum states simultaneously exist.",
                        "Poststructuralist literary criticism challenges traditional hermeneutical methodologies by deconstructing binary oppositions and exposing the inherent instability of textual meaning. Derridean deconstruction reveals how linguistic signification operates through différance, perpetually deferring fixed semantic interpretation.",
                        "Neuroplasticity research elucidates the brain's extraordinary capacity for synaptic reorganization throughout the lifespan. Epigenetic modifications influence gene expression patterns, demonstrating how environmental stimuli can alter neuronal connectivity and subsequently modify cognitive behavioral responses.",
                        "Macroeconomic fluctuations reflect complex interdependencies between fiscal policy implementations, monetary policy adjustments, and international trade dynamics. Keynesian countercyclical interventions aim to mitigate recessionary pressures through strategic governmental expenditure increases and monetary supply expansions."
                    ],
                    code: [
                        "function calculateSum(array) { return array.reduce((accumulator, currentValue) => accumulator + currentValue, 0); }",
                        "const apiResponse = await fetch('/api/users').then(response => response.json()).catch(error => console.error(error));",
                        "class DatabaseManager { constructor(connectionString) { this.connection = new Connection(connectionString); } async query(sql, params) { return await this.connection.execute(sql, params); } }",
                        "import React, { useState, useEffect } from 'react'; const Component = () => { const [data, setData] = useState([]); useEffect(() => { fetchData().then(setData); }, []); return <div>{data.map(item => <span key={item.id}>{item.name}</span>)}</div>; };",
                        "SELECT u.username, p.title, COUNT(c.id) as comment_count FROM users u INNER JOIN posts p ON u.id = p.user_id LEFT JOIN comments c ON p.id = c.post_id WHERE p.created_at >= '2023-01-01' GROUP BY u.id, p.id ORDER BY comment_count DESC LIMIT 10;"
                    ]
                };
                this.currentText = '';
                this.startTime = 0;
                this.timeRemaining = 60;
                this.isTyping = false;
                this.interval = null;
                this.totalWords = 0;
                this.correctChars = 0;
                this.totalChars = 0;
                this.errors = 0;
                this.difficulty = 'medium';
            }

            start() {
                if (this.isTyping) {
                    // Reset if already running
                    clearInterval(this.interval);
                    this.reset();
                }
                
                const duration = parseInt(document.getElementById('typing-duration').value);
                this.difficulty = document.getElementById('typing-difficulty').value;
                this.timeRemaining = duration;
                
                const textCollection = this.textCollections[this.difficulty];
                this.currentText = textCollection[Math.floor(Math.random() * textCollection.length)];
                this.startTime = Date.now();
                this.isTyping = true;
                this.correctChars = 0;
                this.totalChars = 0;
                this.errors = 0;

                document.getElementById('typing-text').textContent = this.currentText;
                const input = document.getElementById('typing-input');
                input.disabled = false;
                input.value = '';
                input.focus();

                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.updateStats();
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('typing-timer').textContent = this.timeRemaining;

                if (this.timeRemaining <= 0) {
                    this.endTest();
                }
            }

            handleInput() {
                if (!this.isTyping) return;

                const input = document.getElementById('typing-input');
                const typed = input.value;
                this.totalChars = typed.length;

                // Count correct characters
                this.correctChars = 0;
                for (let i = 0; i < Math.min(typed.length, this.currentText.length); i++) {
                    if (typed[i] === this.currentText[i]) {
                        this.correctChars++;
                    }
                }

                // Check if current text is completed
                if (typed.length >= this.currentText.length && typed === this.currentText) {
                    this.nextText();
                }

                this.updateStats();
                this.updateTextDisplay(typed);
            }

            nextText() {
                // Get a new random text from current difficulty
                const textCollection = this.textCollections[this.difficulty];
                this.currentText = textCollection[Math.floor(Math.random() * textCollection.length)];
                
                // Clear input and reset display
                const input = document.getElementById('typing-input');
                input.value = '';
                
                // Update display
                document.getElementById('typing-text').textContent = this.currentText;
                
                // Play completion sound
                this.playSound(659.25, 0.2);
            }

            updateTextDisplay(typed) {
                const textDiv = document.getElementById('typing-text');
                let html = '';

                for (let i = 0; i < this.currentText.length; i++) {
                    if (i < typed.length) {
                        if (typed[i] === this.currentText[i]) {
                            html += `<span style="background-color: rgba(76, 175, 80, 0.3);">${this.currentText[i]}</span>`;
                        } else {
                            html += `<span style="background-color: rgba(244, 67, 54, 0.3);">${this.currentText[i]}</span>`;
                        }
                    } else if (i === typed.length) {
                        html += `<span style="background-color: rgba(255, 255, 255, 0.3);">${this.currentText[i]}</span>`;
                    } else {
                        html += this.currentText[i];
                    }
                }

                textDiv.innerHTML = html;
            }

            updateStats() {
                const timeElapsed = (Date.now() - this.startTime) / 1000 / 60; // minutes
                const words = Math.max(this.correctChars / 5, 0); // Standard: 5 characters = 1 word
                const rawWords = Math.max(this.totalChars / 5, 0); // Raw WPM includes errors
                const wpm = timeElapsed > 0 ? Math.round(words / timeElapsed) : 0;
                const rawWpm = timeElapsed > 0 ? Math.round(rawWords / timeElapsed) : 0;
                const accuracy = this.totalChars > 0 ? Math.round((this.correctChars / this.totalChars) * 100) : 100;
                
                // Count errors
                this.errors = this.totalChars - this.correctChars;

                document.getElementById('typing-wpm').textContent = wpm;
                document.getElementById('typing-raw-wpm').textContent = rawWpm;
                document.getElementById('typing-accuracy').textContent = accuracy + '%';
                document.getElementById('typing-errors').textContent = this.errors;
            }

            endTest() {
                this.isTyping = false;
                clearInterval(this.interval);
                
                const input = document.getElementById('typing-input');
                input.disabled = true;

                const timeElapsed = (Date.now() - this.startTime) / 1000 / 60;
                const words = Math.max(this.correctChars / 5, 0);
                const wpm = timeElapsed > 0 ? Math.round(words / timeElapsed) : 0;
                const accuracy = this.totalChars > 0 ? Math.round((this.correctChars / this.totalChars) * 100) : 100;

                const duration = parseInt(document.getElementById('typing-duration').value);
                const diffStats = gameStats.data.typing[duration];
                const overallStats = gameStats.data.typing.overall;
                const timePlayed = Date.now() - this.startTime;

                gameStats.updateGame('typing', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestWPM: Math.max(diffStats.bestWPM, wpm),
                        bestAccuracy: Math.max(diffStats.bestAccuracy, accuracy),
                        totalTime: diffStats.totalTime + timePlayed,
                        tests: [...diffStats.tests.slice(-19), { wpm, accuracy }]
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestWPM: Math.max(overallStats.bestWPM, wpm),
                        bestAccuracy: Math.max(overallStats.bestAccuracy, accuracy),
                        totalTime: overallStats.totalTime + timePlayed,
                        tests: [...overallStats.tests.slice(-19), { wpm, accuracy }]
                    },
                    timePlayed: timePlayed
                }, duration);

                this.playSound(523.25, 0.5);
                gameModal.show('⌨️ Test Complete!', `WPM: ${wpm}<br>Accuracy: ${accuracy}%<br>Errors: ${this.errors}`, 'typing', this);
            }

            reset() {
                this.isTyping = false;
                clearInterval(this.interval);
                
                document.getElementById('typing-input').disabled = true;
                document.getElementById('typing-input').value = '';
                document.getElementById('typing-text').textContent = 'Press "Start Test" to begin typing challenge';
                document.getElementById('typing-wpm').textContent = '0';
                document.getElementById('typing-accuracy').textContent = '100%';
                document.getElementById('typing-timer').textContent = '60';
            }


            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let typingGame = new TypingGame();

        function startTyping() {
            typingGame.start();
        }

        function resetTyping() {
            typingGame.reset();
        }

        // Game 6: Color Matcher Game
        class ColorGame {
            constructor() {
                this.colors = [
                    { name: 'RED', value: '#f44336' },
                    { name: 'BLUE', value: '#2196F3' },
                    { name: 'GREEN', value: '#4CAF50' },
                    { name: 'YELLOW', value: '#FFEB3B' },
                    { name: 'PURPLE', value: '#9C27B0' },
                    { name: 'ORANGE', value: '#FF9800' }
                ];
                this.currentColor = null;
                this.score = 0;
                this.streak = 0;
                this.gameRunning = false;
                this.startTime = null;
                this.timeRemaining = 30;
                this.interval = null;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    clearInterval(this.interval);
                }
                this.score = 0;
                this.streak = 0;
                this.timeRemaining = 30;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.nextRound();
                this.updateDisplay();
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('color-timer').textContent = this.timeRemaining;
                
                if (this.timeRemaining <= 0) {
                    this.endGame();
                }
            }

            nextRound() {
                if (!this.gameRunning) return;

                // Choose random color name and random color for display
                const nameColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                const displayColor = this.colors[Math.floor(Math.random() * this.colors.length)];

                this.currentColor = nameColor;
                const wordDiv = document.getElementById('color-word');
                wordDiv.textContent = nameColor.name;
                wordDiv.style.color = displayColor.value;

                document.getElementById('color-feedback').textContent = 'Match the meaning of the word, not its color!';
            }

            selectColor(colorName) {
                if (!this.gameRunning) return;

                const correct = colorName === this.currentColor.name.toLowerCase();
                
                if (correct) {
                    this.score += 10 + this.streak;
                    this.streak++;
                    this.playSound(523.25, 0.1);
                    document.getElementById('color-feedback').textContent = `Correct! +${10 + this.streak - 1} points`;
                } else {
                    this.streak = 0;
                    this.playSound(220, 0.2);
                    document.getElementById('color-feedback').textContent = `Wrong! The answer was ${this.currentColor.name.toLowerCase()}`;
                }

                gameStats.updateGame('color', {
                    gamesPlayed: gameStats.data.color.gamesPlayed,
                    highScore: Math.max(gameStats.data.color.highScore, this.score),
                    bestStreak: Math.max(gameStats.data.color.bestStreak, this.streak),
                    totalTime: gameStats.data.color.totalTime,
                    correct: gameStats.data.color.correct + (correct ? 1 : 0),
                    total: gameStats.data.color.total + 1
                });

                this.updateDisplay();
                
                setTimeout(() => this.nextRound(), 1500);
            }

            updateDisplay() {
                document.getElementById('color-score').textContent = this.score;
                document.getElementById('color-streak').textContent = this.streak;
            }

            endGame() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                const timePlayed = Date.now() - this.startTime;
                gameStats.updateGame('color', {
                    gamesPlayed: gameStats.data.color.gamesPlayed + 1,
                    highScore: Math.max(gameStats.data.color.highScore, this.score),
                    bestStreak: Math.max(gameStats.data.color.bestStreak, this.streak),
                    totalTime: gameStats.data.color.totalTime + timePlayed
                });

                gameModal.show('🎨 Time\'s Up!', `Final Score: ${this.score}<br>Best Streak: ${this.streak}`, 'color', this);
            }

            reset() {
                this.gameRunning = false;
                clearInterval(this.interval);
                this.score = 0;
                this.streak = 0;
                this.timeRemaining = 30;
                this.currentColor = null;

                document.getElementById('color-word').textContent = 'RED';
                document.getElementById('color-word').style.color = '#f44336';
                document.getElementById('color-feedback').textContent = 'Match the meaning of the word, not its color!';
                document.getElementById('color-timer').textContent = '30';
                this.updateDisplay();
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let colorGame = new ColorGame();

        function startColorMatch() {
            colorGame.start();
        }

        function selectColor(color) {
            colorGame.selectColor(color);
        }

        function resetColorMatch() {
            colorGame.reset();
        }

        // Game 7: Math Quiz
        class MathGame {
            constructor() {
                this.score = 0;
                this.timeRemaining = 30;
                this.gameRunning = false;
                this.interval = null;
                this.startTime = null;
                this.currentAnswer = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    clearInterval(this.interval);
                    this.reset();
                }
                
                this.score = 0;
                this.timeRemaining = 30;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.totalQuestions = 0;
                this.correctAnswers = 0;

                document.getElementById('math-input').disabled = false;
                document.getElementById('math-input').value = '';
                
                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.generateQuestion();
                this.updateDisplay();
            }

            generateQuestion() {
                const difficulty = document.getElementById('math-difficulty').value;
                let num1, num2, operation, question;

                switch (difficulty) {
                    case 'easy':
                        num1 = Math.floor(Math.random() * 20) + 1;
                        num2 = Math.floor(Math.random() * 20) + 1;
                        operation = Math.random() < 0.5 ? '+' : '-';
                        break;
                    case 'medium':
                        num1 = Math.floor(Math.random() * 50) + 1;
                        num2 = Math.floor(Math.random() * 50) + 1;
                        const operations = ['+', '-', '×'];
                        operation = operations[Math.floor(Math.random() * operations.length)];
                        break;
                    case 'hard':
                        num1 = Math.floor(Math.random() * 100) + 1;
                        num2 = Math.floor(Math.random() * 20) + 1;
                        const allOps = ['+', '-', '×', '÷'];
                        operation = allOps[Math.floor(Math.random() * allOps.length)];
                        if (operation === '÷') {
                            num1 = num2 * (Math.floor(Math.random() * 10) + 1);
                        }
                        break;
                }

                switch (operation) {
                    case '+':
                        this.currentAnswer = num1 + num2;
                        question = `${num1} + ${num2}`;
                        break;
                    case '-':
                        if (num1 < num2) [num1, num2] = [num2, num1];
                        this.currentAnswer = num1 - num2;
                        question = `${num1} - ${num2}`;
                        break;
                    case '×':
                        this.currentAnswer = num1 * num2;
                        question = `${num1} × ${num2}`;
                        break;
                    case '÷':
                        this.currentAnswer = num1 / num2;
                        question = `${num1} ÷ ${num2}`;
                        break;
                }

                document.getElementById('math-question').textContent = question + ' = ?';
            }

            submitAnswer() {
                if (!this.gameRunning) return;

                const input = document.getElementById('math-input');
                const userAnswer = parseFloat(input.value);

                this.totalQuestions++;

                if (userAnswer === this.currentAnswer) {
                    this.score += 5;
                    this.correctAnswers++;
                    this.playSound(523.25, 0.1);
                } else {
                    this.playSound(220, 0.1);
                }

                input.value = '';
                this.updateDisplay();
                this.generateQuestion();
            }

            skipQuestion() {
                if (!this.gameRunning) return;

                this.totalQuestions++;
                document.getElementById('math-input').value = '';
                this.generateQuestion();
                this.playSound(330, 0.1);
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('math-timer').textContent = this.timeRemaining;

                if (this.timeRemaining <= 0) {
                    this.endGame();
                }
            }

            updateDisplay() {
                document.getElementById('math-score').textContent = this.score;
            }

            endGame() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                document.getElementById('math-input').disabled = true;
                document.getElementById('math-question').textContent = 'Game Over!';

                const accuracy = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;

                const difficulty = document.getElementById('math-difficulty').value;
                const diffStats = gameStats.data.math[difficulty];
                const overallStats = gameStats.data.math.overall;
                const timePlayed = Date.now() - this.startTime;

                gameStats.updateGame('math', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        highScore: Math.max(diffStats.highScore, this.score),
                        totalTime: diffStats.totalTime + timePlayed,
                        correct: diffStats.correct + this.correctAnswers,
                        total: diffStats.total + this.totalQuestions
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        highScore: Math.max(overallStats.highScore, this.score),
                        totalTime: overallStats.totalTime + timePlayed,
                        correct: overallStats.correct + this.correctAnswers,
                        total: overallStats.total + this.totalQuestions
                    },
                    timePlayed: timePlayed
                }, difficulty);

                this.playSound(523.25, 0.5);
                gameModal.show('➕ Time\'s Up!', `Score: ${this.score}<br>Questions: ${this.totalQuestions}<br>Accuracy: ${accuracy}%`, 'math', this);
            }

            reset() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                this.score = 0;
                this.timeRemaining = 30;
                this.totalQuestions = 0;
                this.correctAnswers = 0;

                document.getElementById('math-input').disabled = true;
                document.getElementById('math-input').value = '';
                document.getElementById('math-question').textContent = 'Press Start to Begin';
                document.getElementById('math-timer').textContent = '30';
                this.updateDisplay();
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let mathGame = new MathGame();

        function startMath() {
            mathGame.start();
        }

        function submitMath() {
            mathGame.submitAnswer();
        }

        function skipMath() {
            mathGame.skipQuestion();
        }

        function resetMath() {
            mathGame.reset();
        }

        // Game 8: Simon Says
        class SimonGame {
            constructor() {
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                this.gameRunning = false;
                this.showingSequence = false;
                this.difficulty = 'medium';
                this.allColors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'cyan', 'pink'];
                this.colors = ['red', 'blue', 'green', 'yellow']; // Will be set based on difficulty
                this.sounds = {
                    red: 220,
                    blue: 277.18,
                    green: 329.63,
                    yellow: 369.99,
                    purple: 415.30,
                    orange: 466.16,
                    cyan: 523.25,
                    pink: 587.33
                };
                this.difficultySettings = {
                    easy: { colors: 4, speed: { pause: 150, show: 250 } },
                    medium: { colors: 4, speed: { pause: 100, show: 200 } },
                    hard: { colors: 6, speed: { pause: 80, show: 180 } },
                    expert: { colors: 8, speed: { pause: 60, show: 150 } }
                };
                this.startTime = null;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    this.reset();
                }
                
                this.difficulty = document.getElementById('simon-difficulty').value;
                this.setupDifficulty();
                
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                this.gameRunning = true;
                this.startTime = Date.now();
                
                document.getElementById('simon-status').textContent = 'Watch the sequence...';
                this.updateDisplay();
                this.nextLevel();
            }

            setupDifficulty() {
                const settings = this.difficultySettings[this.difficulty];
                const numColors = settings.colors;
                this.colors = this.allColors.slice(0, numColors);
                
                // Show/hide buttons based on difficulty
                document.querySelectorAll('.simon-button').forEach((button, index) => {
                    if (index < numColors) {
                        button.style.display = 'block';
                    } else {
                        button.style.display = 'none';
                    }
                });
            }

            nextLevel() {
                if (!this.gameRunning) return;
                
                this.level++;
                this.playerSequence = [];
                
                // Add new color to sequence
                const randomColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                this.sequence.push(randomColor);
                
                this.updateDisplay();
                document.getElementById('simon-status').textContent = `Level ${this.level} - Watch carefully!`;
                
                setTimeout(() => this.showSequence(), 1000);
            }

            async showSequence() {
                this.showingSequence = true;
                const settings = this.difficultySettings[this.difficulty];
                
                for (let i = 0; i < this.sequence.length; i++) {
                    await this.sleep(settings.speed.pause);
                    this.activateButton(this.sequence[i]);
                    await this.sleep(settings.speed.show);
                    this.deactivateButton(this.sequence[i]);
                }
                
                this.showingSequence = false;
                document.getElementById('simon-status').textContent = 'Now repeat the sequence!';
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            activateButton(color) {
                const button = document.querySelector(`.simon-button.${color}`);
                button.classList.add('active');
                this.playSound(this.sounds[color], 0.3);
            }

            deactivateButton(color) {
                const button = document.querySelector(`.simon-button.${color}`);
                button.classList.remove('active');
            }

            buttonClick(color) {
                if (!this.gameRunning || this.showingSequence) return;

                this.activateButton(color);
                setTimeout(() => this.deactivateButton(color), 200);

                this.playerSequence.push(color);
                const currentIndex = this.playerSequence.length - 1;

                if (this.playerSequence[currentIndex] !== this.sequence[currentIndex]) {
                    this.gameOver();
                    return;
                }

                if (this.playerSequence.length === this.sequence.length) {
                    document.getElementById('simon-status').textContent = 'Correct! Next level coming...';
                    setTimeout(() => this.nextLevel(), 1500);
                }
            }

            gameOver() {
                this.gameRunning = false;
                this.showingSequence = false;
                this.playerSequence = [];
                const timePlayed = Date.now() - this.startTime;
                const finalLevel = this.level;

                // Update difficulty-specific stats
                const diffStats = gameStats.data.simon[this.difficulty];
                gameStats.data.simon[this.difficulty] = {
                    gamesPlayed: diffStats.gamesPlayed + 1,
                    highLevel: Math.max(diffStats.highLevel, finalLevel),
                    totalTime: diffStats.totalTime + timePlayed,
                    levels: [...diffStats.levels.slice(-19), finalLevel]
                };

                // Update overall stats
                const overallStats = gameStats.data.simon.overall;
                gameStats.data.simon.overall = {
                    gamesPlayed: overallStats.gamesPlayed + 1,
                    highLevel: Math.max(overallStats.highLevel, finalLevel),
                    totalTime: overallStats.totalTime + timePlayed,
                    levels: [...overallStats.levels.slice(-19), finalLevel],
                    lastPlayed: Date.now()
                };

                gameStats.saveStats();

                this.playSound(150, 0.8);
                document.getElementById('simon-status').textContent = `❌ Wrong! Game Over! You reached level ${finalLevel}`;
                this.updateDisplay();
                
                // Enable start button
                document.getElementById('simon-start').disabled = false;
                
                gameModal.show('🎵 Game Over!', `You reached level ${finalLevel}`, 'simon', this, this.difficulty);
            }

            reset() {
                this.gameRunning = false;
                this.showingSequence = false;
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                
                document.querySelectorAll('.simon-button').forEach(button => {
                    button.classList.remove('active');
                });
                
                document.getElementById('simon-status').textContent = 'Press Start to begin the sequence';
                this.updateDisplay();
            }

            updateDisplay() {
                document.getElementById('simon-level').textContent = Math.max(this.level - 1, 0);
                document.getElementById('simon-best').textContent = gameStats.data.simon.highLevel;
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let simonGame = new SimonGame();

        function startSimon() {
            simonGame.start();
        }

        function simonClick(color) {
            simonGame.buttonClick(color);
        }

        function resetSimon() {
            simonGame.reset();
        }

        // Initialize games when page loads
        document.addEventListener('DOMContentLoaded', function() {
            gameStats.updateGlobalStats();
            
            // Initialize Snake game canvas
            setTimeout(() => {
                snakeGame = new SnakeGame();
            }, 100);

            // Setup Enter key for number guessing
            document.getElementById('guess-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') makeGuess();
            });

            // Setup typing input handler
            document.getElementById('typing-input').addEventListener('input', function() {
                typingGame.handleInput();
            });

            // Setup math input handler
            document.getElementById('math-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') submitMath();
            });

            // Initialize all game displays
            typingGame.reset();
            mathGame.reset();
            simonGame.updateDisplay();
        });
    </script>

    <!-- Game Completion Modal -->
    <div id="game-modal" class="game-modal">
        <div class="modal-content">
            <div class="modal-title" id="modal-title">🎉 Game Complete!</div>
            <div class="modal-score" id="modal-score">Your score: 100</div>
            <div class="modal-buttons">
                <button class="modal-btn primary" onclick="gameModal.restartGame()">🔄 Play Again</button>
                <button class="modal-btn" onclick="gameModal.goToMenu()">🏠 Main Menu</button>
                <button class="modal-btn" onclick="gameModal.changeDifficulty()">⚙️ Settings</button>
            </div>
        </div>
    </div>
</body>
</html>
