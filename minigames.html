<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini-Games Collection</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(255,255,255,0.3); }
            to { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(255,255,255,0.5); }
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
        }

        .nav-tab {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }

        .nav-tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: rgba(255,255,255,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .game-screen {
            display: none;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            animation: fadeIn 0.5s ease-in;
        }

        .game-screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .main-menu {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .game-card {
            background: linear-gradient(135deg, #f8ffae 0%, #43c6ac 100%);
            border-radius: 18px;
            padding: 28px 22px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(67,198,172,0.15);
            border: 1px solid rgba(67,198,172,0.15);
            backdrop-filter: blur(8px);
        }

        .game-card:hover {
            transform: translateY(-5px);
            background: rgba(255,255,255,0.2);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .game-card h3 {
            margin-bottom: 10px;
            font-size: 1.5rem;
            color: #2d3a4b;
        }

        .game-card p {
            opacity: 0.85;
            margin-bottom: 15px;
            color: #3a4d5c;
        }

        .play-btn {
            background: linear-gradient(90deg, #ffaf7b 0%, #d76d77 100%);
            border: none;
            color: #fff;
            padding: 13px 28px;
            border-radius: 28px;
            cursor: pointer;
            font-size: 1.08rem;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
            box-shadow: 0 6px 18px rgba(215,109,119,0.18);
        }

        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .game-content {
            text-align: center;
            min-height: 400px;
        }

        .game-title {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .game-controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(90deg, #43c6ac 0%, #191654 100%);
            border: none;
            color: #fff;
            padding: 13px 26px;
            border-radius: 28px;
            cursor: pointer;
            font-size: 1.08rem;
            transition: all 0.3s cubic-bezier(.25,.8,.25,1);
            box-shadow: 0 6px 18px rgba(67,198,172,0.18);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn.danger {
            background: linear-gradient(90deg, #f85032 0%, #e73827 100%);
        }

        .btn.secondary {
            background: linear-gradient(90deg, #607d8b 0%, #455a64 100%);
        }

        .game-area {
            background: rgba(0,0,0,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .score-display {
            font-size: 1.5rem;
            margin: 15px 0;
            text-align: center;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            border-radius: 14px;
            padding: 22px 18px;
            text-align: center;
            box-shadow: 0 4px 18px rgba(142,197,252,0.12);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 7px;
        }

        .stat-label {
            opacity: 0.85;
            font-size: 1rem;
            color: #2d3a4b;
        }

        .canvas {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            background: rgba(0,0,0,0.1);
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input, .input-group select {
            width: 100%;
            max-width: 300px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 1rem;
            backdrop-filter: blur(10px);
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: 0 auto;
        }

        .memory-card {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: all 0.3s ease;
            user-select: none;
        }

        .memory-card:hover {
            transform: scale(1.05);
        }

        .memory-card.flipped {
            background: rgba(255,255,255,0.4);
        }

        .typing-text {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 1.2rem;
            line-height: 1.6;
            margin: 20px 0;
        }

        .typing-input {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-family: monospace;
        }

        .simon-button {
            width: 80px;
            height: 80px;
            margin: 5px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 4px solid rgba(255,255,255,0.3);
        }

        .simon-button:hover {
            transform: scale(1.1);
        }

        .simon-button.red { background: #f44336; }
        .simon-button.blue { background: #2196F3; }
        .simon-button.green { background: #4CAF50; }
        .simon-button.yellow { background: #FFEB3B; }

        .simon-button.active {
            transform: scale(1.2);
            filter: brightness(1.5);
            box-shadow: 0 0 20px currentColor;
        }

        .achievements {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .achievement {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            position: relative;
        }

        .achievement.unlocked {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            animation: achievementUnlock 0.5s ease-out;
        }

        @keyframes achievementUnlock {
            from { transform: scale(0.8) rotate(-5deg); }
            to { transform: scale(1) rotate(0deg); }
        }

        .achievement-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        /* Game Completion Modal */
        .game-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f8ffae 0%, #43c6ac 100%);
            padding: 44px 32px;
            border-radius: 24px;
            text-align: center;
            max-width: 520px;
            width: 92%;
            box-shadow: 0 24px 72px rgba(67,198,172,0.22);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .modal-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #fff;
        }

        .modal-score {
            font-size: 1.5rem;
            margin-bottom: 30px;
            color: #4CAF50;
            font-weight: bold;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .modal-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }

        .modal-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .modal-btn.primary {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            border-color: #4CAF50;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                min-height: 100vh;
                overflow-y: auto;
            }
            .header h1 {
                font-size: 2rem;
            }
            .nav-tabs {
                flex-direction: column;
                align-items: center;
            }
            .game-screen {
                padding: 20px;
                min-height: 70vh;
                overflow-y: auto;
            }
            .main-menu {
                max-height: 50vh;
                overflow-y: auto;
            }
            .memory-grid {
                grid-template-columns: repeat(3, 1fr);
                max-width: 300px;
            }
            .simon-button {
                width: 60px;
                height: 60px;
            }
            .modal-content {
                padding: 30px 20px;
            }
            .modal-buttons {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 Mini-Games Collection</h1>
            <p>Challenge yourself with 8 exciting games!</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showScreen('menu')">🏠 Menu</button>
            <button class="nav-tab" onclick="showScreen('snake')">🐍 Snake</button>
            <button class="nav-tab" onclick="showScreen('memory')">🧠 Memory</button>
            <button class="nav-tab" onclick="showScreen('reaction')">⚡ Reaction</button>
            <button class="nav-tab" onclick="showScreen('guess')">🔢 Guess</button>
            <button class="nav-tab" onclick="showScreen('typing')">⌨️ Typing</button>
            <button class="nav-tab" onclick="showScreen('color')">🎨 Color</button>
            <button class="nav-tab" onclick="showScreen('math')">➕ Math</button>
            <button class="nav-tab" onclick="showScreen('simon')">🎵 Simon</button>
            <button class="nav-tab" onclick="showScreen('stats')">📊 Stats</button>
        </div>

        <!-- Main Menu -->
        <div id="menu-screen" class="game-screen active">
            <div class="main-menu">
                <div class="game-card" onclick="showScreen('snake')">
                    <h3>🐍 Snake Game</h3>
                    <p>Eat food, grow your snake, and avoid walls! <br><em>Goal:</em> Get the highest score possible. <br><strong>Fun:</strong> Fast-paced, classic arcade challenge!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('memory')">
                    <h3>🧠 Memory Match</h3>
                    <p>Flip cards to find pairs. <br><em>Goal:</em> Match all pairs in the fewest moves. <br><strong>Fun:</strong> Test and improve your memory!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('reaction')">
                    <h3>⚡ Reaction Time</h3>
                    <p>Click as fast as you can when the color changes. <br><em>Goal:</em> Achieve the fastest reaction time. <br><strong>Fun:</strong> Compete with your reflexes!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('guess')">
                    <h3>🔢 Number Guess</h3>
                    <p>Guess the secret number. <br><em>Goal:</em> Find the number in the fewest attempts. <br><strong>Fun:</strong> Logic and luck combined!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('typing')">
                    <h3>⌨️ Typing Speed</h3>
                    <p>Type the given text as fast and accurately as possible. <br><em>Goal:</em> Maximize your WPM and accuracy. <br><strong>Fun:</strong> Challenge your typing skills!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('color')">
                    <h3>🎨 Color Match</h3>
                    <p>Match the color name to the correct color. <br><em>Goal:</em> Score as many points as possible. <br><strong>Fun:</strong> Fast, tricky, and visual!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('math')">
                    <h3>➕ Math Quiz</h3>
                    <p>Answer rapid-fire math questions. <br><em>Goal:</em> Get the highest score with accuracy. <br><strong>Fun:</strong> Quick thinking and calculation!</p>
                    <button class="play-btn">Play Now</button>
                </div>
                <div class="game-card" onclick="showScreen('simon')">
                    <h3>🎵 Simon Says</h3>
                    <p>Repeat the color sequence. <br><em>Goal:</em> Reach the highest level. <br><strong>Fun:</strong> Memory and rhythm challenge!</p>
                    <button class="play-btn">Play Now</button>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-games">0</div>
                    <div class="stat-label">Total Games Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-time">0m</div>
                    <div class="stat-label">Total Time Played</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="achievements-count">0</div>
                    <div class="stat-label">Achievements Unlocked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="current-streak">0</div>
                    <div class="stat-label">Current Win Streak</div>
                </div>
            </div>
        </div>

        <!-- Snake Game -->
        <div id="snake-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🐍 Snake Game</h2>
                <div class="score-display">Score: <span id="snake-score">0</span></div>
                <div class="game-area">
                    <canvas id="snake-canvas" class="canvas" width="400" height="400"></canvas>
                </div>
                <div class="game-controls">
                    <button class="btn" id="snake-start" onclick="startSnake()">Start Game</button>
                    <button class="btn secondary" id="snake-pause" onclick="pauseSnake()" disabled>Pause</button>
                    <button class="btn danger" onclick="resetSnake()">Reset</button>
                    <select id="snake-difficulty">
                        <option value="easy">Easy (Slow)</option>
                        <option value="medium" selected>Medium (Normal)</option>
                        <option value="hard">Hard (Fast)</option>
                    </select>
                    <select id="snake-mode">
                        <option value="classic">Classic Mode</option>
                        <option value="accelerate">Accelerating Mode</option>
                    </select>
                </div>
                <p>Use WASD or Arrow keys to control the snake</p>
            </div>
        </div>

        <!-- Memory Game -->
        <div id="memory-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🧠 Memory Match</h2>
                <div class="score-display">
                    Moves: <span id="memory-moves">0</span> | 
                    Pairs: <span id="memory-pairs">0</span>/8
                </div>
                <div class="game-area">
                    <div id="memory-grid" class="memory-grid"></div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startMemory()">New Game</button>
                    <select id="memory-difficulty">
                        <option value="easy">Easy (3x4)</option>
                        <option value="medium" selected>Medium (4x4)</option>
                        <option value="hard">Hard (5x4)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Reaction Time -->
        <div id="reaction-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">⚡ Reaction Time Test</h2>
                <div class="score-display">Best Time: <span id="reaction-best">N/A</span>ms</div>
                <div class="game-area">
                    <div id="reaction-area" style="width: 300px; height: 200px; background: #f44336; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 1.5rem; transition: all 0.3s ease; position: relative;">
                        <div id="reaction-circle" style="width: 50px; height: 50px; background: #4CAF50; border-radius: 50%; position: absolute; display: none; cursor: pointer;"></div>
                        <span id="reaction-text">Click to Start</span>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startReaction()">Start Test</button>
                    <button class="btn secondary" onclick="resetReaction()">Reset</button>
                    <select id="reaction-mode">
                        <option value="area">Click Area Mode</option>
                        <option value="circle">Click Circle Mode</option>
                    </select>
                </div>
                <p id="reaction-status">Click "Start Test" to begin</p>
            </div>
        </div>

        <!-- Number Guessing -->
        <div id="guess-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🔢 Number Guessing Game</h2>
                <div class="score-display">
                    Attempts: <span id="guess-attempts">0</span> | 
                    Best: <span id="guess-best">N/A</span>
                </div>
                <div class="game-area">
                    <div class="input-group">
                        <label for="guess-input">Guess a number between 1 and 100:</label>
                        <input type="number" id="guess-input" min="1" max="100" placeholder="Enter your guess">
                    </div>
                    <div class="game-controls">
                        <button class="btn" onclick="makeGuess()">Submit Guess</button>
                        <button class="btn secondary" onclick="startGuessing()">New Game</button>
                        <select id="guess-difficulty">
                            <option value="easy">Easy (1-50)</option>
                            <option value="medium" selected>Medium (1-100)</option>
                            <option value="hard">Hard (1-500)</option>
                        </select>
                    </div>
                    <div id="guess-feedback" style="margin-top: 20px; font-size: 1.2rem;"></div>
                    <div id="guess-hints" style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; display: none;">
                        <strong>Hint:</strong> <span id="hint-text"></span>
                    </div>
                    <div id="guess-history" style="margin-top: 15px; font-size: 0.9rem; opacity: 0.8;"></div>
                </div>
            </div>
        </div>

        <!-- Typing Speed Test -->
        <div id="typing-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">⌨️ Typing Speed Test</h2>
                <div class="score-display">
                    WPM: <span id="typing-wpm">0</span> | 
                    Accuracy: <span id="typing-accuracy">100%</span>
                </div>
                <div class="game-area">
                    <div id="typing-text" class="typing-text"></div>
                    <input type="text" id="typing-input" class="typing-input" placeholder="Start typing here..." disabled>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startTyping()">Start Test</button>
                    <button class="btn secondary" onclick="resetTyping()">Reset</button>
                    <select id="typing-duration">
                        <option value="30">30 seconds</option>
                        <option value="60" selected>60 seconds</option>
                        <option value="120">2 minutes</option>
                    </select>
                    <select id="typing-difficulty">
                        <option value="easy">Easy (Simple words)</option>
                        <option value="medium" selected>Medium (Mixed text)</option>
                        <option value="hard">Hard (Complex text)</option>
                        <option value="code">Coding (Code snippets)</option>
                    </select>
                </div>
                <div class="score-display">
                    Time: <span id="typing-timer">60</span>s | 
                    Raw WPM: <span id="typing-raw-wpm">0</span> | 
                    Errors: <span id="typing-errors">0</span>
                </div>
            </div>
        </div>

        <!-- Color Matcher -->
        <div id="color-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🎨 Color Matcher</h2>
                <div class="score-display">
                    Score: <span id="color-score">0</span> | 
                    Streak: <span id="color-streak">0</span> | 
                    Time: <span id="color-timer">30</span>s
                </div>
                <div class="game-area">
                    <div id="color-word" style="font-size: 3rem; margin: 20px; font-weight: bold;">RED</div>
                    <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
                        <button class="btn" onclick="selectColor('red')" style="background: #f44336;">Red</button>
                        <button class="btn" onclick="selectColor('blue')" style="background: #2196F3;">Blue</button>
                        <button class="btn" onclick="selectColor('green')" style="background: #4CAF50;">Green</button>
                        <button class="btn" onclick="selectColor('yellow')" style="background: #FFEB3B; color: black;">Yellow</button>
                        <button class="btn" onclick="selectColor('purple')" style="background: #9C27B0;">Purple</button>
                        <button class="btn" onclick="selectColor('orange')" style="background: #FF9800;">Orange</button>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startColorMatch()">Start Game</button>
                    <button class="btn secondary" onclick="resetColorMatch()">Reset</button>
                </div>
                <p id="color-feedback">Match the meaning of the word, not its color!</p>
            </div>
        </div>

        <!-- Math Quiz -->
        <div id="math-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">➕ Math Quiz</h2>
                <div class="score-display">
                    Score: <span id="math-score">0</span> | 
                    Time: <span id="math-timer">30</span>s
                </div>
                <div class="game-area">
                    <div id="math-question" style="font-size: 2.5rem; margin: 20px;">Press Start to Begin</div>
                    <div class="input-group">
                        <input type="number" id="math-input" placeholder="Enter your answer" disabled>
                    </div>
                    <div class="game-controls">
                        <button class="btn" onclick="submitMath()">Submit</button>
                        <button class="btn secondary" onclick="skipMath()">Skip</button>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startMath()">Start Quiz</button>
                    <button class="btn secondary" onclick="resetMath()">Reset</button>
                    <select id="math-difficulty">
                        <option value="easy">Easy (+, -)</option>
                        <option value="medium" selected>Medium (+, -, ×)</option>
                        <option value="hard">Hard (+, -, ×, ÷)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Simon Says -->
        <div id="simon-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">🎵 Simon Says</h2>
                <div class="score-display">
                    Level: <span id="simon-level">0</span> | 
                    Best: <span id="simon-best">0</span>
                </div>
                <div class="game-area">
                    <div id="simon-buttons" style="display: flex; flex-wrap: wrap; justify-content: center; max-width: 400px; margin: 0 auto;">
                        <div class="simon-button red" onclick="simonClick('red')" data-color="red"></div>
                        <div class="simon-button blue" onclick="simonClick('blue')" data-color="blue"></div>
                        <div class="simon-button green" onclick="simonClick('green')" data-color="green"></div>
                        <div class="simon-button yellow" onclick="simonClick('yellow')" data-color="yellow"></div>
                        <div class="simon-button purple" onclick="simonClick('purple')" data-color="purple" style="display: none; background: #9C27B0;"></div>
                        <div class="simon-button orange" onclick="simonClick('orange')" data-color="orange" style="display: none; background: #FF9800;"></div>
                        <div class="simon-button cyan" onclick="simonClick('cyan')" data-color="cyan" style="display: none; background: #00BCD4;"></div>
                        <div class="simon-button pink" onclick="simonClick('pink')" data-color="pink" style="display: none; background: #E91E63;"></div>
                    </div>
                </div>
                <div class="game-controls">
                    <button class="btn" onclick="startSimon()">Start Game</button>
                    <button class="btn secondary" onclick="resetSimon()">Reset</button>
                    <select id="simon-difficulty">
                        <option value="easy">Easy (4 colors)</option>
                        <option value="medium" selected>Medium (4 colors, faster)</option>
                        <option value="hard">Hard (6 colors)</option>
                        <option value="expert">Expert (8 colors)</option>
                    </select>
                </div>
                <p id="simon-status">Press Start to begin the sequence</p>
            </div>
        </div>

        <!-- Statistics Dashboard -->
        <div id="stats-screen" class="game-screen">
            <div class="game-content">
                <h2 class="game-title">📊 Statistics Dashboard</h2>
                <div class="game-controls">
                    <button class="btn secondary" onclick="exportStats()">Export Data</button>
                    <button class="btn danger" onclick="clearStats()">Clear All Stats</button>
                    <button class="btn" onclick="showSessionStats()">📊 Session Analytics</button>
                </div>
                
                <!-- Session Analytics Panel -->
                <div id="session-analytics" style="display: none; margin-bottom: 30px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px;">
                        <div class="stat-card">
                            <h3>🎯 Current Session</h3>
                            <div id="current-session-stats"></div>
                        </div>
                        <div class="stat-card">
                            <h3>📈 Performance Trends</h3>
                            <div id="performance-trends"></div>
                        </div>
                        <div class="stat-card">
                            <h3>🏆 Daily Progress</h3>
                            <div id="daily-progress"></div>
                        </div>
                        <div class="stat-card">
                            <h3>🎮 Live Metrics</h3>
                            <div id="live-metrics"></div>
                        </div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 15px;">📊 Performance Rating History</h3>
                        <canvas id="rating-chart" width="800" height="200" style="width: 100%; max-width: 800px; height: auto; background: rgba(0,0,0,0.1); border-radius: 10px;"></canvas>
                    </div>
                </div>
                
                <div id="stats-content"></div>
                
                <!-- Leaderboards Section -->
                <div style="margin: 30px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3>🏆 Leaderboards</h3>
                        <button class="btn secondary" onclick="toggleLeaderboards()">Show/Hide Leaderboards</button>
                    </div>
                    <div id="leaderboards-section" style="display: none;">
                        <div id="leaderboards-content"></div>
                    </div>
                </div>
                
                <h3 style="margin-top: 30px; margin-bottom: 20px;">🏆 Achievements</h3>
                <div id="achievements-display" class="achievements"></div>
            </div>
        </div>
    </div>

    <script>
        // Statistics and Game State Management
        class GameStats {
            constructor() {
                this.data = this.loadStats();
                this.achievements = this.loadAchievements();
                this.sessionStart = Date.now();
            }

            loadStats() {
                const saved = localStorage.getItem('miniGameStats');
                if (!saved) return this.getDefaultStats();
                
                const data = JSON.parse(saved);
                // Migrate old data structure to new difficulty-based structure
                return this.migrateStats(data);
            }

            migrateStats(data) {
                const defaultStats = this.getDefaultStats();
                
                // Check if data needs migration (old structure)
                if (data.snake && typeof data.snake.gamesPlayed === 'number') {
                    // Migrate to new structure
                    Object.keys(data).forEach(game => {
                        if (game !== 'global' && data[game]) {
                            if (defaultStats[game]?.overall) {
                                // Copy old stats to overall
                                defaultStats[game].overall = { ...data[game] };
                            } else {
                                // Keep as-is for games without difficulty structure
                                defaultStats[game] = data[game];
                            }
                        }
                    });
                    defaultStats.global = data.global || defaultStats.global;
                    return defaultStats;
                }
                
                // Ensure all fields exist with defaults
                Object.keys(defaultStats).forEach(game => {
                    if (!data[game]) {
                        data[game] = defaultStats[game];
                    } else if (data[game].overall) {
                        // Ensure all difficulty levels exist
                        Object.keys(defaultStats[game]).forEach(difficulty => {
                            if (!data[game][difficulty]) {
                                data[game][difficulty] = defaultStats[game][difficulty];
                            }
                        });
                    }
                });
                
                return data;
            }

            getDefaultStats() {
                return {
                    snake: { 
                        easy: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        easy_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        easy_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        medium_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard_classic: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        hard_accelerate: { gamesPlayed: 0, highScore: 0, totalTime: 0 },
                        overall: { gamesPlayed: 0, highScore: 0, totalTime: 0, lastPlayed: null }
                    },
                    memory: { 
                        easy: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        medium: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        hard: { gamesPlayed: 0, bestMoves: null, totalTime: 0, wins: 0 },
                        overall: { gamesPlayed: 0, bestMoves: null, totalTime: 0, winRate: 0, wins: 0, lastPlayed: null }
                    },
                    reaction: { 
                        area: { gamesPlayed: 0, bestTime: null, totalTime: 0, tests: [] },
                        circle: { gamesPlayed: 0, bestTime: null, totalTime: 0, tests: [] },
                        overall: { gamesPlayed: 0, bestTime: null, averageTime: 0, totalTime: 0, tests: [], lastPlayed: null }
                    },
                    guess: { 
                        easy: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        medium: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        hard: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0 },
                        overall: { gamesPlayed: 0, bestAttempts: null, totalTime: 0, wins: 0, winRate: 0, lastPlayed: null }
                    },
                    typing: { 
                        30: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        60: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        120: { gamesPlayed: 0, bestWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [] },
                        overall: { gamesPlayed: 0, bestWPM: 0, averageWPM: 0, bestAccuracy: 0, totalTime: 0, tests: [], lastPlayed: null }
                    },
                    color: { gamesPlayed: 0, highScore: 0, bestStreak: 0, totalTime: 0, accuracy: 0, correct: 0, total: 0, lastPlayed: null },
                    math: { 
                        easy: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        medium: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        hard: { gamesPlayed: 0, highScore: 0, totalTime: 0, correct: 0, total: 0 },
                        overall: { gamesPlayed: 0, highScore: 0, totalTime: 0, accuracy: 0, correct: 0, total: 0, lastPlayed: null }
                    },
                    simon: {
                        easy: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        medium: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        hard: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        expert: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [] },
                        overall: { gamesPlayed: 0, highLevel: 0, totalTime: 0, levels: [], lastPlayed: null }
                    },
                    global: { totalGames: 0, totalTime: 0, currentStreak: 0, bestStreak: 0, lastActivity: null, sessionStart: Date.now() }
                };
            }

            loadAchievements() {
                const saved = localStorage.getItem('miniGameAchievements');
                return saved ? JSON.parse(saved) : {};
            }

            saveStats() {
                localStorage.setItem('miniGameStats', JSON.stringify(this.data));
                localStorage.setItem('miniGameAchievements', JSON.stringify(this.achievements));
            }

            updateGame(game, updates, difficulty = null) {
                // Update difficulty-specific stats if applicable
                if (difficulty && this.data[game][difficulty]) {
                    Object.assign(this.data[game][difficulty], updates.difficulty || {});
                }
                
                // Update overall game stats
                if (this.data[game].overall) {
                    Object.assign(this.data[game].overall, updates.overall || updates);
                    this.data[game].overall.lastPlayed = Date.now();
                } else {
                    Object.assign(this.data[game], updates);
                    this.data[game].lastPlayed = Date.now();
                }
                
                this.data.global.totalGames++;
                this.data.global.lastActivity = Date.now();
                
                // Update total time more accurately
                if (updates.timePlayed || updates.totalTime) {
                    const timeToAdd = updates.timePlayed || updates.totalTime || 0;
                    this.data.global.totalTime += timeToAdd;
                }
                
                this.saveStats();
                this.checkAchievements();
                this.updateGlobalStats();
            }

            updateGlobalStats() {
                // Update global statistics
                document.getElementById('total-games').textContent = this.data.global.totalGames;
                
                const totalMinutes = Math.floor(this.data.global.totalTime / 60000);
                document.getElementById('total-time').textContent = totalMinutes + 'm';
                
                document.getElementById('achievements-count').textContent = Object.keys(this.achievements).length;
                document.getElementById('current-streak').textContent = this.data.global.currentStreak;
            }

            checkAchievements() {
                const achievements = [
                    { id: 'first_game', name: 'First Steps', desc: 'Play your first game', icon: '🌟', 
                      check: () => this.data.global.totalGames >= 1 },
                    { id: 'game_master', name: 'Game Master', desc: 'Play 100 games', icon: '🎮', 
                      check: () => this.data.global.totalGames >= 100 },
                    { id: 'snake_master', name: 'Snake Master', desc: 'Score 200+ in Snake', icon: '🐍', 
                      check: () => (this.data.snake.overall?.highScore || 0) >= 200 },
                    { id: 'memory_genius', name: 'Memory Genius', desc: 'Complete Memory in 20 moves', icon: '🧠', 
                      check: () => this.data.memory.overall?.bestMoves && this.data.memory.overall.bestMoves <= 20 },
                    { id: 'lightning_fast', name: 'Lightning Fast', desc: 'React in under 200ms', icon: '⚡', 
                      check: () => this.data.reaction.overall?.bestTime && this.data.reaction.overall.bestTime < 200 },
                    { id: 'lucky_guesser', name: 'Lucky Guesser', desc: 'Guess number in 3 tries', icon: '🍀', 
                      check: () => this.data.guess.overall?.bestAttempts && this.data.guess.overall.bestAttempts <= 3 },
                    { id: 'typing_speed', name: 'Speed Demon', desc: 'Type 80+ WPM', icon: '⌨️', 
                      check: () => (this.data.typing.overall?.bestWPM || 0) >= 80 },
                    { id: 'color_streak', name: 'Color Expert', desc: 'Get 25 color matches in a row', icon: '🎨', 
                      check: () => this.data.color.bestStreak >= 25 },
                    { id: 'math_wizard', name: 'Math Wizard', desc: 'Score 50+ in Math Quiz', icon: '🧮', 
                      check: () => (this.data.math.overall?.highScore || 0) >= 50 },
                    { id: 'simon_master', name: 'Simon Master', desc: 'Reach level 15 in Simon', icon: '🎵', 
                      check: () => this.data.simon.highLevel >= 15 },
                    { id: 'perfectionist', name: 'Perfectionist', desc: '100% accuracy in any typing test', icon: '💯', 
                      check: () => (this.data.typing.overall?.bestAccuracy || 0) >= 100 },
                    { id: 'time_master', name: 'Time Master', desc: 'Play for 2+ hours total', icon: '⏰', 
                      check: () => this.data.global.totalTime >= 7200000 },
                    { id: 'streak_master', name: 'Streak Master', desc: 'Win 10 games in a row', icon: '🔥', 
                      check: () => this.data.global.bestStreak >= 10 },
                    { id: 'all_rounder', name: 'All-Rounder', desc: 'Play every game at least once', icon: '🌟', 
                      check: () => Object.keys(this.data).filter(k => k !== 'global').every(game => (this.data[game].overall?.gamesPlayed || this.data[game].gamesPlayed || 0) > 0) },
                    { id: 'dedicated', name: 'Dedicated Player', desc: 'Play games on 7 different days', icon: '📅', 
                      check: () => this.getDaysPlayed() >= 7 }
                ];

                achievements.forEach(achievement => {
                    if (!this.achievements[achievement.id] && achievement.check()) {
                        this.achievements[achievement.id] = {
                            ...achievement,
                            unlockedAt: Date.now()
                        };
                        this.showAchievement(achievement);
                    }
                });

                this.updateAchievementsDisplay();
            }

            getDaysPlayed() {
                const days = new Set();
                Object.keys(this.data).forEach(game => {
                    if (game !== 'global') {
                        const lastPlayed = this.data[game].overall?.lastPlayed || this.data[game].lastPlayed;
                        if (lastPlayed) {
                            const day = new Date(lastPlayed).toDateString();
                            days.add(day);
                        }
                    }
                });
                return days.size;
            }

            showAchievement(achievement) {
                // Create achievement notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: linear-gradient(45deg, #4CAF50, #45a049);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    z-index: 1000;
                    animation: slideIn 0.5s ease-out;
                    max-width: 300px;
                `;
                notification.innerHTML = `
                    <div style="font-size: 2rem; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-weight: bold; margin-bottom: 5px;">Achievement Unlocked!</div>
                    <div style="font-size: 1.1rem; margin-bottom: 5px;">${achievement.name}</div>
                    <div style="opacity: 0.9;">${achievement.desc}</div>
                `;

                document.body.appendChild(notification);
                
                // Add slide-in animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(style);

                // Auto-remove after 4 seconds
                setTimeout(() => {
                    notification.style.animation = 'slideIn 0.5s ease-out reverse';
                    setTimeout(() => notification.remove(), 500);
                }, 4000);

                // Play achievement sound
                this.playAchievementSound();
            }

            playAchievementSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            updateAchievementsDisplay() {
                const container = document.getElementById('achievements-display');
                if (!container) return;

                const allAchievements = [
                    { id: 'first_game', name: 'First Steps', desc: 'Play your first game', icon: '🌟' },
                    { id: 'game_master', name: 'Game Master', desc: 'Play 100 games', icon: '🎮' },
                    { id: 'snake_master', name: 'Snake Master', desc: 'Score 200+ in Snake', icon: '🐍' },
                    { id: 'memory_genius', name: 'Memory Genius', desc: 'Complete Memory in 20 moves', icon: '🧠' },
                    { id: 'lightning_fast', name: 'Lightning Fast', desc: 'React in under 200ms', icon: '⚡' },
                    { id: 'lucky_guesser', name: 'Lucky Guesser', desc: 'Guess number in 3 tries', icon: '🍀' },
                    { id: 'typing_speed', name: 'Speed Demon', desc: 'Type 80+ WPM', icon: '⌨️' },
                    { id: 'color_streak', name: 'Color Expert', desc: 'Get 25 color matches in a row', icon: '🎨' },
                    { id: 'math_wizard', name: 'Math Wizard', desc: 'Score 50+ in Math Quiz', icon: '🧮' },
                    { id: 'simon_master', name: 'Simon Master', desc: 'Reach level 15 in Simon', icon: '🎵' },
                    { id: 'perfectionist', name: 'Perfectionist', desc: '100% accuracy in typing', icon: '💯' },
                    { id: 'time_master', name: 'Time Master', desc: 'Play for 2+ hours total', icon: '⏰' },
                    { id: 'streak_master', name: 'Streak Master', desc: 'Win 10 games in a row', icon: '🔥' },
                    { id: 'all_rounder', name: 'All-Rounder', desc: 'Play every game', icon: '🌟' },
                    { id: 'dedicated', name: 'Dedicated Player', desc: 'Play on 7 different days', icon: '📅' }
                ];

                container.innerHTML = allAchievements.map(achievement => {
                    const unlocked = this.achievements[achievement.id];
                    return `
                        <div class="achievement ${unlocked ? 'unlocked' : ''}">
                            <div class="achievement-icon">${achievement.icon}</div>
                            <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                            <div style="opacity: 0.8; font-size: 0.9rem;">${achievement.desc}</div>
                            ${unlocked ? `<div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">Unlocked: ${new Date(unlocked.unlockedAt).toLocaleDateString()}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            exportStats() {
                const data = {
                    stats: this.data,
                    achievements: this.achievements,
                    exportDate: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `minigames-stats-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearStats() {
                if (confirm('Are you sure you want to clear all statistics and achievements? This cannot be undone.')) {
                    localStorage.removeItem('miniGameStats');
                    localStorage.removeItem('miniGameAchievements');
                    this.data = this.getDefaultStats();
                    this.achievements = {};
                    this.updateGlobalStats();
                    this.updateAchievementsDisplay();
                    this.displayStats();
                }
            }

            displayStats() {
                const container = document.getElementById('stats-content');
                if (!container) return;

                const games = ['snake', 'memory', 'reaction', 'guess', 'typing', 'color', 'math', 'simon'];
                const gameNames = {
                    snake: '🐍 Snake',
                    memory: '🧠 Memory Match',
                    reaction: '⚡ Reaction Time',
                    guess: '🔢 Number Guess',
                    typing: '⌨️ Typing Speed',
                    color: '🎨 Color Match',
                    math: '➕ Math Quiz',
                    simon: '🎵 Simon Says'
                };

                container.innerHTML = `
                    <div id="stats-overview">
                        <div class="stats-grid">
                            ${games.map(game => {
                                const stats = this.data[game];
                                const overall = stats.overall || stats;
                                const timePlayed = Math.floor((overall.totalTime || 0) / 60000);
                                return `
                                    <div class="stat-card" onclick="gameStats.showDetailedStats('${game}')" style="cursor: pointer; transition: transform 0.2s;">
                                        <h3 style="margin-bottom: 15px;">${gameNames[game]}</h3>
                                        <div class="stat-value">${overall.gamesPlayed || 0}</div>
                                        <div class="stat-label">Games Played</div>
                                        <div style="margin-top: 10px;">
                                            ${this.getGameSpecificStats(game, stats)}
                                        </div>
                                        <div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">
                                            Time played: ${timePlayed}m
                                        </div>
                                        ${overall.lastPlayed ? `<div style="font-size: 0.8rem; opacity: 0.7;">Last played: ${new Date(overall.lastPlayed).toLocaleDateString()}</div>` : ''}
                                        <div style="margin-top: 10px; font-size: 0.8rem; color: #4CAF50;">Click for details ↗</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <div id="detailed-stats" style="display: none;">
                        <button class="btn secondary" onclick="gameStats.showOverview()" style="margin-bottom: 20px;">← Back to Overview</button>
                        <div id="detailed-content"></div>
                    </div>
                `;
            }

            getGameSpecificStats(game, stats) {
                const overall = stats.overall || stats;
                switch(game) {
                    case 'snake':
                        return `High Score: ${overall.highScore || 0}`;
                    case 'memory':
                        return `Best: ${overall.bestMoves || 'N/A'} moves<br>Win Rate: ${overall.gamesPlayed ? Math.round((overall.wins / overall.gamesPlayed) * 100) : 0}%`;
                    case 'reaction':
                        return `Best: ${overall.bestTime || 'N/A'}ms<br>Average: ${overall.tests?.length ? Math.round(overall.tests.reduce((a,b) => a+b, 0) / overall.tests.length) : 'N/A'}ms`;
                    case 'guess':
                        return `Best: ${overall.bestAttempts || 'N/A'} attempts<br>Win Rate: ${overall.gamesPlayed ? Math.round((overall.wins / overall.gamesPlayed) * 100) : 0}%`;
                    case 'typing':
                        return `Best: ${overall.bestWPM || 0} WPM<br>Best Accuracy: ${overall.bestAccuracy || 0}%`;
                    case 'color':
                        return `High Score: ${overall.highScore || 0}<br>Best Streak: ${overall.bestStreak || 0}<br>Accuracy: ${overall.total ? Math.round((overall.correct / overall.total) * 100) : 0}%`;
                    case 'math':
                        return `High Score: ${overall.highScore || 0}<br>Accuracy: ${overall.total ? Math.round((overall.correct / overall.total) * 100) : 0}%`;
                    case 'simon':
                        return `Best Level: ${overall.highLevel || 0}<br>Average: ${overall.levels?.length ? Math.round(overall.levels.reduce((a,b) => a+b, 0) / overall.levels.length) : 0}`;
                    default:
                        return '';
                }
            }

            showDetailedStats(game) {
                document.getElementById('stats-overview').style.display = 'none';
                document.getElementById('detailed-stats').style.display = 'block';
                
                const stats = this.data[game];
                const gameNames = {
                    snake: '🐍 Snake',
                    memory: '🧠 Memory Match',
                    reaction: '⚡ Reaction Time',
                    guess: '🔢 Number Guess',
                    typing: '⌨️ Typing Speed',
                    color: '🎨 Color Match',
                    math: '➕ Math Quiz',
                    simon: '🎵 Simon Says'
                };
                
                let content = `<h2>${gameNames[game]} - Detailed Stats</h2>`;
                
                if (stats.overall) {
                    // Game with difficulty levels
                    content += this.generateDetailedStatsForGame(game, stats);
                } else {
                    // Game without difficulty levels
                    content += this.generateBasicStatsForGame(game, stats);
                }
                
                document.getElementById('detailed-content').innerHTML = content;
            }

            generateDetailedStatsForGame(game, stats) {
                let content = `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Overall Stats</h3>
                            ${this.generateStatsTable(stats.overall)}
                        </div>`;
                
                Object.keys(stats).forEach(difficulty => {
                    if (difficulty !== 'overall') {
                        const difficultyName = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
                        content += `
                            <div class="stat-card">
                                <h3>${difficultyName} Difficulty</h3>
                                ${this.generateStatsTable(stats[difficulty], difficulty)}
                            </div>`;
                    }
                });
                
                content += `</div>`;
                return content;
            }

            generateBasicStatsForGame(game, stats) {
                return `
                    <div class="stats-grid">
                        <div class="stat-card">
                            <h3>Game Stats</h3>
                            ${this.generateStatsTable(stats)}
                        </div>
                    </div>`;
            }

            generateStatsTable(stats, difficulty = null) {
                let table = '<table style="width: 100%; border-collapse: collapse;">';
                
                Object.keys(stats).forEach(key => {
                    if (key === 'tests' || key === 'levels') return; // Skip arrays for now
                    
                    let label = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                    let value = stats[key];
                    
                    if (key === 'totalTime' && value) {
                        value = `${Math.floor(value / 60000)}m ${Math.floor((value % 60000) / 1000)}s`;
                    } else if (key === 'lastPlayed' && value) {
                        value = new Date(value).toLocaleString();
                    } else if (key === 'winRate' || key === 'accuracy') {
                        value = value ? `${Math.round(value)}%` : '0%';
                    }
                    
                    table += `
                        <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <td style="padding: 8px; opacity: 0.8;">${label}:</td>
                            <td style="padding: 8px; font-weight: bold; color: #4CAF50;">${value || 'N/A'}</td>
                        </tr>`;
                });
                
                table += '</table>';
                
                // Add performance graph if we have historical data
                if (stats.tests && stats.tests.length > 1) {
                    table += this.generatePerformanceGraph(stats.tests, difficulty);
                } else if (stats.levels && stats.levels.length > 1) {
                    table += this.generatePerformanceGraph(stats.levels, difficulty, 'Level');
                }
                
                return table;
            }

            generatePerformanceGraph(data, difficulty = null, label = 'Performance') {
                const canvasId = `chart-${difficulty || 'default'}-${Math.random().toString(36).substr(2, 9)}`;
                
                // Prepare data for chart
                const chartData = Array.isArray(data[0]) ? data.map(d => d.wpm || d.accuracy || d) : data;
                const maxValue = Math.max(...chartData);
                const minValue = Math.min(...chartData);
                
                setTimeout(() => this.drawChart(canvasId, chartData, label), 100);
                
                return `
                    <div style="margin-top: 15px;">
                        <h4 style="margin-bottom: 10px;">📈 ${label} Over Time</h4>
                        <canvas id="${canvasId}" width="300" height="150" style="background: rgba(0,0,0,0.1); border-radius: 8px; width: 100%; max-width: 300px; height: auto;"></canvas>
                        <div style="text-align: center; font-size: 0.8rem; opacity: 0.7; margin-top: 5px;">
                            Last ${chartData.length} games | Range: ${minValue} - ${maxValue}
                        </div>
                    </div>
                `;
            }

            drawChart(canvasId, data, label) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const padding = 30;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;
                
                ctx.clearRect(0, 0, width, height);
                
                // Set colors
                ctx.strokeStyle = '#4CAF50';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
                ctx.lineWidth = 2;
                ctx.font = '12px Arial';
                ctx.fillStyle = '#fff';
                
                if (data.length === 0) return;
                
                const maxValue = Math.max(...data);
                const minValue = Math.min(...data);
                const range = maxValue - minValue || 1;
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + (graphHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // Draw the chart line
                ctx.strokeStyle = '#4CAF50';
                ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const stepX = graphWidth / (data.length - 1);
                
                for (let i = 0; i < data.length; i++) {
                    const x = padding + stepX * i;
                    const normalizedValue = range > 0 ? (data[i] - minValue) / range : 0.5;
                    const y = padding + graphHeight - (normalizedValue * graphHeight);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Fill area under curve
                ctx.lineTo(padding + stepX * (data.length - 1), padding + graphHeight);
                ctx.lineTo(padding, padding + graphHeight);
                ctx.closePath();
                ctx.fill();
                
                // Draw data points
                ctx.fillStyle = '#4CAF50';
                for (let i = 0; i < data.length; i++) {
                    const x = padding + stepX * i;
                    const normalizedValue = range > 0 ? (data[i] - minValue) / range : 0.5;
                    const y = padding + graphHeight - (normalizedValue * graphHeight);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.textAlign = 'center';
                ctx.fillText(minValue.toString(), padding, height - 10);
                ctx.fillText(maxValue.toString(), padding, 20);
            }

            showOverview() {
                document.getElementById('detailed-stats').style.display = 'none';
                document.getElementById('stats-overview').style.display = 'block';
            }
        }

        // Performance Analytics System
        class PerformanceAnalytics {
            constructor() {
                this.sessionData = {
                    startTime: Date.now(),
                    gamesPlayed: 0,
                    totalScore: 0,
                    averageScore: 0,
                    streak: 0,
                    bestStreak: 0,
                    gamesSinceLastBest: 0,
                    skillTrend: 'stable', // improving, declining, stable
                    performanceRating: 1000, // ELO-style rating
                    dailyGoals: { target: 10, completed: 0 },
                    weeklyStats: this.loadWeeklyStats()
                };
                this.liveMetrics = {
                    currentWPM: 0,
                    currentAccuracy: 100,
                    reactionTimes: [],
                    gameIntensity: 0,
                    focusLevel: 100
                };
                this.charts = {};
                this.startSession();
            }

            startSession() {
                const today = new Date().toDateString();
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                if (!sessions[today]) {
                    sessions[today] = { gamesPlayed: 0, timeSpent: 0, achievements: 0 };
                }
                localStorage.setItem('gameSessions', JSON.stringify(sessions));
            }

            updateLiveMetric(metric, value) {
                this.liveMetrics[metric] = value;
                this.broadcastMetricUpdate(metric, value);
            }

            broadcastMetricUpdate(metric, value) {
                const event = new CustomEvent('liveMetricUpdate', {
                    detail: { metric, value, timestamp: Date.now() }
                });
                document.dispatchEvent(event);
            }

            trackGameCompletion(game, difficulty, score, won = true) {
                this.sessionData.gamesPlayed++;
                this.sessionData.totalScore += score;
                this.sessionData.averageScore = this.sessionData.totalScore / this.sessionData.gamesPlayed;
                
                if (won) {
                    this.sessionData.streak++;
                    this.sessionData.bestStreak = Math.max(this.sessionData.bestStreak, this.sessionData.streak);
                    this.sessionData.gamesSinceLastBest = 0;
                } else {
                    this.sessionData.streak = 0;
                    this.sessionData.gamesSinceLastBest++;
                }

                this.updatePerformanceRating(game, score, won);
                this.updateDailyStats();
                this.analyzeSkillTrend();
            }

            updatePerformanceRating(game, score, won) {
                const baseChange = won ? 25 : -15;
                const scoreMultiplier = Math.min(score / 100, 2); // Cap at 2x
                const streakBonus = Math.min(this.sessionData.streak * 2, 20);
                
                const change = Math.round(baseChange * scoreMultiplier + streakBonus);
                this.sessionData.performanceRating = Math.max(100, this.sessionData.performanceRating + change);
            }

            analyzeSkillTrend() {
                const recentGames = Math.min(this.sessionData.gamesPlayed, 10);
                if (recentGames < 5) {
                    this.sessionData.skillTrend = 'stable';
                    return;
                }

                // Analyze last 10 games vs previous 10
                const currentAvg = this.sessionData.averageScore;
                const improvementThreshold = 0.1;
                
                if (this.sessionData.streak >= 3) {
                    this.sessionData.skillTrend = 'improving';
                } else if (this.sessionData.gamesSinceLastBest > 5) {
                    this.sessionData.skillTrend = 'declining';
                } else {
                    this.sessionData.skillTrend = 'stable';
                }
            }

            updateDailyStats() {
                const today = new Date().toDateString();
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                if (sessions[today]) {
                    sessions[today].gamesPlayed++;
                    this.sessionData.dailyGoals.completed = sessions[today].gamesPlayed;
                }
                localStorage.setItem('gameSessions', JSON.stringify(sessions));
            }

            loadWeeklyStats() {
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '{}');
                const weekAgo = new Date();
                weekAgo.setDate(weekAgo.getDate() - 7);
                
                let weeklyGames = 0;
                let weeklyTime = 0;
                
                Object.entries(sessions).forEach(([date, data]) => {
                    const sessionDate = new Date(date);
                    if (sessionDate >= weekAgo) {
                        weeklyGames += data.gamesPlayed || 0;
                        weeklyTime += data.timeSpent || 0;
                    }
                });

                return { gamesPlayed: weeklyGames, timeSpent: weeklyTime };
            }

            getSessionSummary() {
                const sessionTime = (Date.now() - this.sessionData.startTime) / 1000 / 60;
                return {
                    ...this.sessionData,
                    sessionDuration: sessionTime,
                    gamesPerMinute: sessionTime > 0 ? this.sessionData.gamesPlayed / sessionTime : 0,
                    performanceGrade: this.getPerformanceGrade()
                };
            }

            getPerformanceGrade() {
                const rating = this.sessionData.performanceRating;
                if (rating >= 1400) return 'S+';
                if (rating >= 1200) return 'S';
                if (rating >= 1100) return 'A+';
                if (rating >= 1000) return 'A';
                if (rating >= 900) return 'B+';
                if (rating >= 800) return 'B';
                if (rating >= 700) return 'C+';
                return 'C';
            }
        }

        // Initialize analytics and statistics
        const performanceAnalytics = new PerformanceAnalytics();
        const gameStats = new GameStats();

        // Game Modal System
        class GameModal {
            constructor() {
                this.currentGame = '';
                this.currentGameInstance = null;
            }

            show(title, score, gameType, gameInstance, difficulty = 'medium') {
                this.currentGame = gameType;
                this.currentGameInstance = gameInstance;
                this.currentDifficulty = difficulty;
                
                document.getElementById('modal-title').textContent = title;
                
                // Get high scores for this specific game mode and difficulty
                const highScores = this.getHighScores(gameType, difficulty);
                const sessionStats = performanceAnalytics.getSessionSummary();
                
                const enhancedScore = `
                    ${score}
                    <div style="margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px; font-size: 0.9rem;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left;">
                            <div>
                                <strong style="color: #FFD700;">🏆 ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} High Scores</strong><br>
                                ${highScores.slice(0, 3).map((hs, i) => `${i+1}. ${hs}`).join('<br>')}
                            </div>
                            <div>
                                <strong style="color: #4CAF50;">📊 Session Stats</strong><br>
                                Performance: ${sessionStats.performanceGrade} (${sessionStats.performanceRating})<br>
                                Streak: ${sessionStats.streak} games<br>
                                Trend: ${sessionStats.skillTrend === 'improving' ? '📈' : sessionStats.skillTrend === 'declining' ? '📉' : '➡️'} ${sessionStats.skillTrend}
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 10px; font-size: 0.8rem; opacity: 0.7;">
                        Press Enter to play again, Escape to return to menu
                    </div>
                `;
                
                document.getElementById('modal-score').innerHTML = enhancedScore;
                document.getElementById('game-modal').style.display = 'block';
                
                // Add keyboard listener
                this.addKeyboardListener();
                
                // Track completion in analytics
                const gameScore = this.extractScoreFromString(score);
                performanceAnalytics.trackGameCompletion(gameType, difficulty, gameScore, !title.includes('Over') && !title.includes('Up'));
                
                // Animate in
                setTimeout(() => {
                    document.querySelector('.modal-content').style.animation = 'modalSlideIn 0.3s ease-out';
                }, 50);
            }

            getHighScores(gameType, difficulty) {
                const stats = gameStats.data[gameType];
                if (!stats) return ['No scores yet', '', ''];
                
                let scores = [];
                
                // Get multiple scores for proper leaderboard
                switch(gameType) {
                    case 'snake':
                        // Get scores from different modes/difficulties
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highScore > 0) {
                                let label = key.includes('_') ? key.replace('_', ' ') : key;
                                scores.push({ score: stats[key].highScore, label: label });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map((item, i) => `${item.score} (${item.label})`);
                        
                    case 'typing':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestWPM > 0) {
                                let label = key.includes('_') ? key.replace('_', ' ') : key;
                                scores.push({ score: stats[key].bestWPM, label: label });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map((item, i) => `${item.score} WPM (${item.label})`);
                        
                    case 'math':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highScore > 0) {
                                scores.push({ score: stats[key].highScore, label: key });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map(item => `${item.score} (${item.label})`);
                        
                    case 'memory':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestMoves > 0) {
                                scores.push({ score: stats[key].bestMoves, label: key });
                            }
                        });
                        scores.sort((a, b) => a.score - b.score); // Lower is better
                        return scores.slice(0, 3).map(item => `${item.score} moves (${item.label})`);
                        
                    case 'simon':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].highLevel > 0) {
                                scores.push({ score: stats[key].highLevel, label: key });
                            }
                        });
                        scores.sort((a, b) => b.score - a.score);
                        return scores.slice(0, 3).map(item => `Level ${item.score} (${item.label})`);
                        
                    case 'reaction':
                        Object.keys(stats).forEach(key => {
                            if (key !== 'overall' && stats[key] && stats[key].bestTime > 0) {
                                scores.push({ score: stats[key].bestTime, label: key });
                            }
                        });
                        scores.sort((a, b) => a.score - b.score); // Lower is better
                        return scores.slice(0, 3).map(item => `${item.score}ms (${item.label})`);
                        
                    case 'guess':
                        const guessStats = stats.overall || stats;
                        return [`${guessStats.bestAttempts || 'N/A'} attempts`, '', ''];
                        
                    case 'color':
                        return [`${stats.highScore || 0} points`, `${stats.bestStreak || 0} streak`, ''];
                }
                
                // Fallback
                return ['No scores yet', '', ''];
            }

            extractScoreFromString(scoreString) {
                const numbers = scoreString.match(/\d+/g);
                return numbers ? parseInt(numbers[0]) : 0;
            }

            addKeyboardListener() {
                this.keyboardHandler = (e) => {
                    if (document.getElementById('game-modal').style.display === 'block') {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.restartGame();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.goToMenu();
                        }
                    }
                };
                
                document.addEventListener('keydown', this.keyboardHandler);
            }

            removeKeyboardListener() {
                if (this.keyboardHandler) {
                    document.removeEventListener('keydown', this.keyboardHandler);
                    this.keyboardHandler = null;
                }
            }

            hide() {
                document.getElementById('game-modal').style.display = 'none';
                this.removeKeyboardListener();
            }

            restartGame() {
                this.hide();
                // Call the appropriate start function based on current game
                switch(this.currentGame) {
                    case 'snake': startSnake(); break;
                    case 'memory': startMemory(); break;
                    case 'reaction': startReaction(); break;
                    case 'guess': startGuessing(); break;
                    case 'typing': startTyping(); break;
                    case 'color': startColorMatch(); break;
                    case 'math': startMath(); break;
                    case 'simon': startSimon(); break;
                }
            }

            goToMenu() {
                this.hide();
                showScreen('menu');
            }

            changeDifficulty() {
                this.hide();
                // Show the appropriate game screen so user can change settings
                showScreen(this.currentGame);
            }
        }

        const gameModal = new GameModal();

        // Navigation and Screen Management
        function showScreen(screenId) {
            document.querySelectorAll('.game-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(screenId + '-screen').classList.add('active');
            document.querySelector(`[onclick="showScreen('${screenId}')"]`).classList.add('active');

            // Load screen-specific content
            if (screenId === 'stats') {
                gameStats.displayStats();
                gameStats.updateAchievementsDisplay();
            }
        }

        function showSessionStats() {
            const panel = document.getElementById('session-analytics');
            const isVisible = panel.style.display !== 'none';
            
            if (isVisible) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            updateSessionAnalytics();
        }

        function updateSessionAnalytics() {
            const sessionSummary = performanceAnalytics.getSessionSummary();
            const liveMetrics = performanceAnalytics.liveMetrics;
            
            // Current Session Stats
            document.getElementById('current-session-stats').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                    <div><strong>Games Played:</strong> ${sessionSummary.gamesPlayed}</div>
                    <div><strong>Session Time:</strong> ${Math.round(sessionSummary.sessionDuration)}m</div>
                    <div><strong>Performance Grade:</strong> <span style="color: #4CAF50; font-weight: bold;">${sessionSummary.performanceGrade}</span></div>
                    <div><strong>Rating:</strong> ${sessionSummary.performanceRating}</div>
                    <div><strong>Current Streak:</strong> ${sessionSummary.streak}</div>
                    <div><strong>Best Streak:</strong> ${sessionSummary.bestStreak}</div>
                    <div><strong>Avg Score:</strong> ${Math.round(sessionSummary.averageScore)}</div>
                    <div><strong>Skill Trend:</strong> ${sessionSummary.skillTrend === 'improving' ? '📈' : sessionSummary.skillTrend === 'declining' ? '📉' : '➡️'} ${sessionSummary.skillTrend}</div>
                </div>
            `;
            
            // Performance Trends
            document.getElementById('performance-trends').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div style="margin-bottom: 10px;"><strong>Games per minute:</strong> ${sessionSummary.gamesPerMinute.toFixed(2)}</div>
                    <div style="margin-bottom: 10px;"><strong>Focus Level:</strong> <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 10px;"><div style="width: ${liveMetrics.focusLevel}%; background: #4CAF50; height: 100%; border-radius: 10px;"></div></div></div>
                    <div><strong>Game Intensity:</strong> <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 10px;"><div style="width: ${liveMetrics.gameIntensity}%; background: #FF9800; height: 100%; border-radius: 10px;"></div></div></div>
                </div>
            `;
            
            // Daily Progress
            const dailyGoals = sessionSummary.dailyGoals;
            const dailyProgress = Math.min((dailyGoals.completed / dailyGoals.target) * 100, 100);
            document.getElementById('daily-progress').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div style="margin-bottom: 10px;"><strong>Daily Goal:</strong> ${dailyGoals.completed}/${dailyGoals.target} games</div>
                    <div style="width: 100%; background: rgba(255,255,255,0.2); border-radius: 10px; height: 15px; margin-bottom: 10px;">
                        <div style="width: ${dailyProgress}%; background: linear-gradient(45deg, #4CAF50, #8BC34A); height: 100%; border-radius: 10px;"></div>
                    </div>
                    <div><strong>Weekly Games:</strong> ${sessionSummary.weeklyStats.gamesPlayed}</div>
                    <div><strong>Weekly Time:</strong> ${Math.round(sessionSummary.weeklyStats.timeSpent / 60000)}m</div>
                </div>
            `;
            
            // Live Metrics
            document.getElementById('live-metrics').innerHTML = `
                <div style="font-size: 0.9rem;">
                    <div><strong>Live WPM:</strong> ${liveMetrics.currentWPM}</div>
                    <div><strong>Live Accuracy:</strong> ${liveMetrics.currentAccuracy}%</div>
                    <div><strong>Recent Reactions:</strong> ${liveMetrics.reactionTimes.slice(-3).join('ms, ')}${liveMetrics.reactionTimes.length > 0 ? 'ms' : 'None'}</div>
                </div>
            `;
            
            // Draw performance rating chart
            drawPerformanceChart();
        }

        function drawPerformanceChart() {
            const canvas = document.getElementById('rating-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Mock data - in real implementation, this would come from stored rating history
            const ratingHistory = [1000, 1025, 1015, 1040, 1035, 1050, 1045, 1060, 1055, 1070];
            const currentRating = performanceAnalytics.sessionData.performanceRating;
            ratingHistory.push(currentRating);
            
            if (ratingHistory.length < 2) return;
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(width - 50, y);
                ctx.stroke();
            }
            
            // Draw rating line
            const minRating = Math.min(...ratingHistory) - 50;
            const maxRating = Math.max(...ratingHistory) + 50;
            const range = maxRating - minRating;
            
            ctx.strokeStyle = '#4CAF50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            ratingHistory.forEach((rating, index) => {
                const x = 50 + ((width - 100) / (ratingHistory.length - 1)) * index;
                const y = height - 50 - ((rating - minRating) / range) * (height - 100);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#4CAF50';
            ratingHistory.forEach((rating, index) => {
                const x = 50 + ((width - 100) / (ratingHistory.length - 1)) * index;
                const y = height - 50 - ((rating - minRating) / range) * (height - 100);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`${Math.round(maxRating)}`, 10, 20);
            ctx.fillText(`${Math.round(minRating)}`, 10, height - 10);
            ctx.textAlign = 'center';
            ctx.fillText(`Current: ${currentRating}`, width / 2, height - 10);
        }

        function toggleLeaderboards() {
            const section = document.getElementById('leaderboards-section');
            const isVisible = section.style.display !== 'none';
            
            if (isVisible) {
                section.style.display = 'none';
            } else {
                section.style.display = 'block';
                generateLeaderboards();
            }
        }

        function generateLeaderboards() {
            const content = document.getElementById('leaderboards-content');
            const stats = gameStats.data;
            
            let leaderboardHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">';
            
            // Snake Leaderboards
            leaderboardHTML += generateGameLeaderboard('Snake', stats.snake, 'highScore', '🐍');
            
            // Memory Leaderboards
            leaderboardHTML += generateGameLeaderboard('Memory', stats.memory, 'bestMoves', '🧠', true);
            
            // Typing Leaderboards
            leaderboardHTML += generateGameLeaderboard('Typing', stats.typing, 'bestWPM', '⌨️');
            
            // Math Leaderboards
            leaderboardHTML += generateGameLeaderboard('Math', stats.math, 'highScore', '➕');
            
            // Simon Leaderboards
            leaderboardHTML += generateGameLeaderboard('Simon', stats.simon, 'highLevel', '🎵');
            
            // Reaction Time Leaderboards
            leaderboardHTML += generateGameLeaderboard('Reaction', stats.reaction, 'bestTime', '⚡', true);
            
            leaderboardHTML += '</div>';
            content.innerHTML = leaderboardHTML;
        }

        function generateGameLeaderboard(gameName, gameStats, statKey, emoji, lowerIsBetter = false) {
            if (!gameStats) return '';
            
            let html = `<div class="stat-card"><h4>${emoji} ${gameName}</h4><div style="font-size: 0.9rem;">`;
            let hasAnyScores = false;
            
            // Group by difficulty/mode combinations
            Object.keys(gameStats).forEach(key => {
                if (key === 'overall') return;
                const stats = gameStats[key];
                if (!stats || !stats[statKey] || stats[statKey] === 0) return;
                hasAnyScores = true;
                let displayKey = key;
                if (key.includes('_')) {
                    const parts = key.split('_');
                    displayKey = `${parts[0].charAt(0).toUpperCase() + parts[0].slice(1)} (${parts[1].charAt(0).toUpperCase() + parts[1].slice(1)})`;
                } else {
                    displayKey = key.charAt(0).toUpperCase() + key.slice(1);
                }
                // Show top 3 scores for Snake (with date if available)
                let scoresArr = [];
                if (Array.isArray(stats.tests) && stats.tests.length > 0) {
                    scoresArr = [...stats.tests];
                } else if (Array.isArray(stats.levels) && stats.levels.length > 0) {
                    scoresArr = [...stats.levels];
                } else if (stats[statKey]) {
                    scoresArr = [stats[statKey]];
                }
                if (!lowerIsBetter) scoresArr.sort((a,b)=>b-a);
                else scoresArr.sort((a,b)=>a-b);
                let scoreDisplay = scoresArr.slice(0,3).map((s,i)=>{
                    if (statKey === 'bestTime') return `${s}ms`;
                    if (statKey === 'bestWPM') return `${s} WPM`;
                    if (statKey === 'bestMoves') return `${s} moves`;
                    if (statKey === 'highLevel') return `Level ${s}`;
                    return s;
                }).join('<br>');
                html += `
                    <div style="margin-bottom: 10px;">
                        <div style="font-weight: bold; color: #4CAF50; margin-bottom: 3px;">${displayKey}</div>
                        <div style="display: flex; justify-content: space-between; padding: 2px 0;">
                            <span>🥇 Top Scores</span>
                            <span><strong>${scoreDisplay}</strong></span>
                        </div>
                        <div style="font-size: 0.8rem; color: #888;">Games played: ${stats.gamesPlayed || 0}</div>
                    </div>
                `;
            });
            
            if (!hasAnyScores) {
                html += '<div>No scores recorded yet</div>';
            }
            
            html += '</div></div>';
            return html;
        }

        // Export and clear functions
        function exportStats() {
            gameStats.exportStats();
        }

        function clearStats() {
            gameStats.clearStats();
        }

        // Game 1: Snake Game
        class SnakeGame {
            constructor() {
                this.canvas = document.getElementById('snake-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;
                this.reset();
                this.setupControls();
            }

            reset() {
                this.snake = [{x: 10, y: 10}];
                this.dx = 0;
                this.dy = 0;
                this.apple = {x: 15, y: 15};
                this.score = 0;
                this.gameRunning = false;
                this.gamePaused = false;
                this.startTime = null;
                this.speed = 100; // Starting speed (ms between moves)
                this.mode = 'classic';
                this.updateScore();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning || this.gamePaused) return;
                    // Prevent arrow keys from changing select/dropdown focus
                    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
                        if (document.activeElement && (document.activeElement.tagName === "SELECT" || document.activeElement.tagName === "INPUT")) {
                            document.activeElement.blur();
                        }
                        e.preventDefault();
                    }
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            if (this.dy === 0) { this.dx = 0; this.dy = -1; }
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            if (this.dy === 0) { this.dx = 0; this.dy = 1; }
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            if (this.dx === 0) { this.dx = -1; this.dy = 0; }
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            if (this.dx === 0) { this.dx = 1; this.dy = 0; }
                            break;
                    }
                });
            }

            start() {
                if (this.gameRunning) {
                    // Reset the game if already running
                    this.gameRunning = false;
                    document.getElementById('snake-start').disabled = false;
                    document.getElementById('snake-pause').disabled = true;
                }
                this.reset(); // Reset game state
                this.mode = document.getElementById('snake-mode').value;
                this.difficulty = document.getElementById('snake-difficulty').value;
                
                // Set speed based on difficulty
                switch(this.difficulty) {
                    case 'easy': this.speed = 150; break;
                    case 'medium': this.speed = 100; break;
                    case 'hard': this.speed = 70; break;
                }
                
                this.gameRunning = true;
                this.gamePaused = false;
                this.startTime = Date.now();
                document.getElementById('snake-start').disabled = true;
                document.getElementById('snake-pause').disabled = false;
                this.dx = 0; // Don't move during countdown
                this.dy = 0;
                
                // Start countdown
                this.showCountdown(3, () => {
                    this.dx = 1; // Start moving right after countdown
                    this.dy = 0;
                    this.gameLoop();
                });
            }

            pause() {
                this.gamePaused = !this.gamePaused;
                document.getElementById('snake-pause').textContent = this.gamePaused ? 'Resume' : 'Pause';
                if (!this.gamePaused) this.gameLoop();
            }

            gameLoop() {
                if (!this.gameRunning || this.gamePaused) return;

                this.update();
                this.draw();

                if (this.gameRunning) {
                    setTimeout(() => this.gameLoop(), this.speed);
                }
            }

            update() {
                const head = {x: this.snake[0].x + this.dx, y: this.snake[0].y + this.dy};

                // Check wall collision
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
                    this.gameOver();
                    return;
                }

                // Check self collision
                for (let segment of this.snake) {
                    if (head.x === segment.x && head.y === segment.y) {
                        this.gameOver();
                        return;
                    }
                }

                this.snake.unshift(head);

                // Check apple collision
                if (head.x === this.apple.x && head.y === this.apple.y) {
                    this.score += 10;
                    this.updateScore();
                    this.generateApple();
                    this.playSound(523.25, 0.1); // Apple sound
                    
                    // Increase speed in accelerating mode
                    if (this.mode === 'accelerate') {
                        this.speed = Math.max(30, this.speed - 5); // Minimum 30ms, decrease by 5ms each apple
                    }
                } else {
                    this.snake.pop();
                }
            }

            generateApple() {
                do {
                    this.apple = {
                        x: Math.floor(Math.random() * this.tileCount),
                        y: Math.floor(Math.random() * this.tileCount)
                    };
                } while (this.snake.some(segment => segment.x === this.apple.x && segment.y === this.apple.y));
            }

            draw() {
                // Clear canvas completely
                this.ctx.fillStyle = 'rgba(0,0,0,1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw snake
                this.ctx.fillStyle = '#4CAF50';
                for (let segment of this.snake) {
                    this.ctx.fillRect(segment.x * this.gridSize, segment.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                }

                // Draw apple
                this.ctx.fillStyle = '#f44336';
                this.ctx.beginPath();
                this.ctx.arc(
                    this.apple.x * this.gridSize + this.gridSize/2,
                    this.apple.y * this.gridSize + this.gridSize/2,
                    this.gridSize/2 - 2,
                    0,
                    2 * Math.PI
                );
                this.ctx.fill();
            }

            updateScore() {
                document.getElementById('snake-score').textContent = this.score;
            }

            gameOver() {
                this.gameRunning = false;
                document.getElementById('snake-start').disabled = false;
                document.getElementById('snake-pause').disabled = true;
                
                const timePlayed = Date.now() - this.startTime;
                const difficulty = this.difficulty || 'medium';
                const mode = this.mode || 'classic';
                const statsKey = `${difficulty}_${mode}`; // e.g., "medium_accelerate"
                
                // Initialize stats for this specific difficulty-mode combo if needed
                if (!gameStats.data.snake[statsKey]) {
                    gameStats.data.snake[statsKey] = { gamesPlayed: 0, highScore: 0, totalTime: 0 };
                }
                
                // Get current stats for difficulty-mode combo and overall
                const modeStats = gameStats.data.snake[statsKey];
                const diffStats = gameStats.data.snake[difficulty];
                const overallStats = gameStats.data.snake.overall;
                
                // Update mode-specific stats
                gameStats.data.snake[statsKey] = {
                    gamesPlayed: modeStats.gamesPlayed + 1,
                    highScore: Math.max(modeStats.highScore, this.score),
                    totalTime: modeStats.totalTime + timePlayed
                };
                
                // Update difficulty stats
                gameStats.data.snake[difficulty] = {
                    gamesPlayed: diffStats.gamesPlayed + 1,
                    highScore: Math.max(diffStats.highScore, this.score),
                    totalTime: diffStats.totalTime + timePlayed
                };
                
                // Update overall stats
                gameStats.data.snake.overall = {
                    gamesPlayed: overallStats.gamesPlayed + 1,
                    highScore: Math.max(overallStats.highScore, this.score),
                    totalTime: overallStats.totalTime + timePlayed
                };
                
                gameStats.saveStats();

                this.playSound(220, 0.3); // Game over sound
                gameModal.show('🐍 Game Over!', `Score: ${this.score}`, 'snake', this, this.difficulty);
            }

            showCountdown(count, callback) {
                if (count <= 0) {
                    // Clear countdown display and start game
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    callback();
                    return;
                }

                // Draw countdown
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.font = 'bold 72px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(count.toString(), this.canvas.width / 2, this.canvas.height / 2 + 20);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '24px Arial';
                this.ctx.fillText('Get Ready!', this.canvas.width / 2, this.canvas.height / 2 - 50);

                this.playSound(440 + count * 100, 0.2);

                setTimeout(() => {
                    this.showCountdown(count - 1, callback);
                }, 1000);
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let snakeGame;

        function startSnake() {
            if (!snakeGame) snakeGame = new SnakeGame();
            snakeGame.start();
        }

        function pauseSnake() {
            if (snakeGame) snakeGame.pause();
        }

        function resetSnake() {
            if (snakeGame) snakeGame.reset();
        }

        // Game 2: Memory Card Matching Game
        class MemoryGame {
            constructor() {
                this.cards = [];
                this.flippedCards = [];
                this.moves = 0;
                this.pairs = 0;
                this.maxPairs = 8;
                this.gameRunning = false;
                this.startTime = null;
            }

            start() {
                this.reset();
                this.generateCards();
                this.gameRunning = true;
                this.startTime = Date.now();
            }

            reset() {
                this.cards = [];
                this.flippedCards = [];
                this.moves = 0;
                this.pairs = 0;
                this.gameRunning = false;
                this.updateDisplay();
            }

            generateCards() {
                const difficulty = document.getElementById('memory-difficulty').value;
                let gridSize, symbols;

                switch(difficulty) {
                    case 'easy':
                        gridSize = { rows: 3, cols: 4 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊'];
                        this.maxPairs = 6;
                        break;
                    case 'medium':
                        gridSize = { rows: 4, cols: 4 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼'];
                        this.maxPairs = 8;
                        break;
                    case 'hard':
                        gridSize = { rows: 4, cols: 5 };
                        symbols = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼', '🐸', '🐵'];
                        this.maxPairs = 10;
                        break;
                }

                // Create pairs
                const cardSymbols = [...symbols, ...symbols].slice(0, this.maxPairs * 2);
                cardSymbols.sort(() => Math.random() - 0.5);

                this.cards = cardSymbols.map((symbol, index) => ({
                    id: index,
                    symbol: symbol,
                    flipped: false,
                    matched: false
                }));

                this.renderGrid(gridSize);
            }

            renderGrid(gridSize) {
                const grid = document.getElementById('memory-grid');
                grid.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
                
                grid.innerHTML = this.cards.map(card => 
                    `<div class="memory-card" onclick="flipCard(${card.id})" data-id="${card.id}">
                        ${card.flipped || card.matched ? card.symbol : '?'}
                    </div>`
                ).join('');
            }

            flipCard(cardId) {
                if (!this.gameRunning || this.flippedCards.length >= 2) return;

                const card = this.cards[cardId];
                if (card.flipped || card.matched) return;

                card.flipped = true;
                this.flippedCards.push(card);
                this.updateCardDisplay(cardId);

                if (this.flippedCards.length === 2) {
                    this.moves++;
                    this.updateDisplay();
                    
                    setTimeout(() => this.checkMatch(), 1000);
                }
            }

            checkMatch() {
                const [card1, card2] = this.flippedCards;

                if (card1.symbol === card2.symbol) {
                    card1.matched = true;
                    card2.matched = true;
                    this.pairs++;
                    this.playSound(659.25, 0.2); // Match sound

                    if (this.pairs === this.maxPairs) {
                        this.gameWon();
                    }
                } else {
                    card1.flipped = false;
                    card2.flipped = false;
                    this.updateCardDisplay(card1.id);
                    this.updateCardDisplay(card2.id);
                    this.playSound(220, 0.1); // No match sound
                }

                this.flippedCards = [];
                this.updateDisplay();
            }

            updateCardDisplay(cardId) {
                const cardElement = document.querySelector(`[data-id="${cardId}"]`);
                const card = this.cards[cardId];
                cardElement.textContent = card.flipped || card.matched ? card.symbol : '?';
                cardElement.classList.toggle('flipped', card.flipped || card.matched);
            }

            updateDisplay() {
                document.getElementById('memory-moves').textContent = this.moves;
                document.getElementById('memory-pairs').textContent = `${this.pairs}/${this.maxPairs}`;
            }

            gameWon() {
                this.gameRunning = false;
                const timePlayed = Date.now() - this.startTime;
                const difficulty = document.getElementById('memory-difficulty').value;
                
                const diffStats = gameStats.data.memory[difficulty];
                const overallStats = gameStats.data.memory.overall;
                
                gameStats.updateGame('memory', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestMoves: diffStats.bestMoves ? Math.min(diffStats.bestMoves, this.moves) : this.moves,
                        totalTime: diffStats.totalTime + timePlayed,
                        wins: diffStats.wins + 1
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestMoves: overallStats.bestMoves ? Math.min(overallStats.bestMoves, this.moves) : this.moves,
                        totalTime: overallStats.totalTime + timePlayed,
                        wins: overallStats.wins + 1
                    },
                    timePlayed: timePlayed
                }, difficulty);

                this.playSound(523.25, 0.5); // Victory sound
                setTimeout(() => {
                    gameModal.show('🧠 Congratulations!', `You won in ${this.moves} moves!`, 'memory', this, this.difficulty);
                }, 100);
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let memoryGame = new MemoryGame();

        function startMemory() {
            memoryGame.start();
        }

        function flipCard(cardId) {
            memoryGame.flipCard(cardId);
        }

        // Game 3: Reaction Time Test
        class ReactionGame {
            constructor() {
                this.area = document.getElementById('reaction-area');
                this.circle = document.getElementById('reaction-circle');
                this.text = document.getElementById('reaction-text');
                this.isWaiting = false;
                this.startTime = 0;
                this.timeouts = [];
                this.mode = 'area';
            }

            start() {
                if (this.isWaiting) return;
                
                this.mode = document.getElementById('reaction-mode').value;
                this.clearTimeouts();
                this.setupMode();
                this.isWaiting = true;

                const delay = Math.random() * 4000 + 1000; // 1-5 seconds
                const timeout = setTimeout(() => this.showTarget(), delay);
                this.timeouts.push(timeout);
            }

            setupMode() {
                if (this.mode === 'area') {
                    this.area.style.background = '#f44336';
                    this.text.textContent = 'Wait for GREEN...';
                    this.circle.style.display = 'none';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.tooEarly();
                    };
                    this.circle.onclick = null;
                } else {
                    this.area.style.background = '#333';
                    this.text.textContent = 'Wait for GREEN circle...';
                    this.circle.style.display = 'none';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.tooEarly();
                    };
                }
            }

            showTarget() {
                if (!this.isWaiting) return;
                
                this.startTime = performance.now();

                if (this.mode === 'area') {
                    this.area.style.background = '#4CAF50';
                    this.text.textContent = 'CLICK NOW!';
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.clicked();
                    };
                } else {
                    // Position circle randomly
                    const maxX = this.area.clientWidth - 50;
                    const maxY = this.area.clientHeight - 50;
                    const x = Math.random() * maxX;
                    const y = Math.random() * maxY;
                    
                    this.circle.style.left = x + 'px';
                    this.circle.style.top = y + 'px';
                    this.circle.style.display = 'block';
                    this.text.textContent = 'CLICK THE CIRCLE!';
                    
                    this.circle.onclick = () => this.clicked();
                    this.area.onclick = (e) => {
                        if (e.target === this.circle) return;
                        this.missedTarget();
                    };
                }
            }

            clicked() {
                if (!this.isWaiting) return;
                
                const reactionTime = Math.round(performance.now() - this.startTime);
                this.isWaiting = false;
                
                if (this.mode === 'area') {
                    this.area.style.background = '#2196F3';
                    this.text.textContent = `${reactionTime}ms`;
                } else {
                    this.area.style.background = '#2196F3';
                    this.circle.style.display = 'none';
                    this.text.textContent = `${reactionTime}ms`;
                }
                
                this.area.onclick = null;
                this.circle.onclick = null;

                // Update stats for specific mode and overall
                const currentBest = gameStats.data.reaction[this.mode].bestTime;
                const overallBest = gameStats.data.reaction.overall.bestTime;
                const newBest = !currentBest || reactionTime < currentBest;
                const newOverallBest = !overallBest || reactionTime < overallBest;

                gameStats.updateGame('reaction', {
                    difficulty: {
                        gamesPlayed: gameStats.data.reaction[this.mode].gamesPlayed + 1,
                        bestTime: newBest ? reactionTime : currentBest,
                        totalTime: gameStats.data.reaction[this.mode].totalTime + reactionTime,
                        tests: [...gameStats.data.reaction[this.mode].tests.slice(-19), reactionTime]
                    },
                    overall: {
                        gamesPlayed: gameStats.data.reaction.overall.gamesPlayed + 1,
                        bestTime: newOverallBest ? reactionTime : overallBest,
                        totalTime: gameStats.data.reaction.overall.totalTime + reactionTime,
                        tests: [...gameStats.data.reaction.overall.tests.slice(-19), reactionTime]
                    },
                    timePlayed: reactionTime
                }, this.mode);

                document.getElementById('reaction-best').textContent = gameStats.data.reaction.overall.bestTime || 'N/A';
                document.getElementById('reaction-status').textContent = `${this.mode.charAt(0).toUpperCase() + this.mode.slice(1)} mode: ${reactionTime}ms ${newBest ? '(New Best!)' : ''}`;
                
                if (newBest) this.playSound(523.25, 0.3);
                else this.playSound(440, 0.2);
                
                // Click on status area to restart instantly
                document.getElementById('reaction-status').style.cursor = 'pointer';
                document.getElementById('reaction-status').style.padding = '10px';
                document.getElementById('reaction-status').style.border = '2px dashed #4CAF50';
                document.getElementById('reaction-status').style.borderRadius = '5px';
                document.getElementById('reaction-status').onclick = () => this.start();
            }

            missedTarget() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#FF9800';
                this.circle.style.display = 'none';
                this.text.textContent = 'Missed! Click the circle only';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'You missed the target! Click only the green circle.';
                this.playSound(220, 0.3);
            }

            tooEarly() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#FF9800';
                this.circle.style.display = 'none';
                this.text.textContent = 'Too early! Try again';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'You clicked too early! Wait for the target.';
                this.playSound(220, 0.3);
            }

            reset() {
                this.isWaiting = false;
                this.clearTimeouts();
                this.area.style.background = '#f44336';
                this.text.textContent = 'Click to Start';
                this.circle.style.display = 'none';
                this.area.onclick = null;
                this.circle.onclick = null;
                document.getElementById('reaction-status').textContent = 'Click "Start Test" to begin';
                document.getElementById('reaction-status').style.cursor = 'default';
                document.getElementById('reaction-status').style.border = 'none';
                document.getElementById('reaction-status').onclick = null;
            }

            clearTimeouts() {
                this.timeouts.forEach(timeout => clearTimeout(timeout));
                this.timeouts = [];
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let reactionGame = new ReactionGame();

        function startReaction() {
            reactionGame.start();
        }

        function resetReaction() {
            reactionGame.reset();
        }

        // Game 4: Number Guessing Game
        class GuessGame {
            constructor() {
                this.secretNumber = 0;
                this.attempts = 0;
                this.maxNumber = 100;
                this.gameRunning = false;
                this.startTime = null;
                this.guessHistory = [];
                this.range = { min: 1, max: 100 };
            }

            start() {
                const difficulty = document.getElementById('guess-difficulty').value;
                switch(difficulty) {
                    case 'easy': this.maxNumber = 50; break;
                    case 'medium': this.maxNumber = 100; break;
                    case 'hard': this.maxNumber = 500; break;
                }

                this.secretNumber = Math.floor(Math.random() * this.maxNumber) + 1;
                this.attempts = 0;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.guessHistory = [];
                this.range = { min: 1, max: this.maxNumber };
                
                document.getElementById('guess-input').value = '';
                document.getElementById('guess-input').max = this.maxNumber;
                document.getElementById('guess-input').placeholder = `Enter number 1-${this.maxNumber}`;
                document.getElementById('guess-feedback').textContent = `I'm thinking of a number between 1 and ${this.maxNumber}`;
                document.getElementById('guess-hints').style.display = 'none';
                document.getElementById('guess-history').textContent = '';
                this.updateDisplay();
            }

            makeGuess() {
                if (!this.gameRunning) {
                    this.start();
                    return;
                }

                const input = document.getElementById('guess-input');
                const guess = parseInt(input.value);

                if (isNaN(guess) || guess < 1 || guess > this.maxNumber) {
                    document.getElementById('guess-feedback').textContent = `Please enter a valid number between 1 and ${this.maxNumber}`;
                    return;
                }

                // Check for duplicate guess
                if (this.guessHistory.includes(guess)) {
                    document.getElementById('guess-feedback').textContent = `You already guessed ${guess}! Try a different number.`;
                    this.playSound(220, 0.2);
                    return;
                }

                this.attempts++;
                this.guessHistory.push(guess);
                this.updateDisplay();

                if (guess === this.secretNumber) {
                    this.gameWon();
                } else if (guess < this.secretNumber) {
                    this.range.min = Math.max(this.range.min, guess + 1);
                    const diff = this.secretNumber - guess;
                    let feedback = `Too low! Try a higher number.`;
                    
                    if (diff <= 5) feedback += ` 🔥 Very close!`;
                    else if (diff <= 10) feedback += ` Getting warmer!`;
                    
                    document.getElementById('guess-feedback').textContent = feedback;
                    this.playSound(440, 0.1);
                } else {
                    this.range.max = Math.min(this.range.max, guess - 1);
                    const diff = guess - this.secretNumber;
                    let feedback = `Too high! Try a lower number.`;
                    
                    if (diff <= 5) feedback += ` 🔥 Very close!`;
                    else if (diff <= 10) feedback += ` Getting warmer!`;
                    
                    document.getElementById('guess-feedback').textContent = feedback;
                    this.playSound(330, 0.1);
                }

                this.updateHistory();
                this.showHints();
                input.value = '';
            }

            gameWon() {
                this.gameRunning = false;
                const timePlayed = Date.now() - this.startTime;
                const difficulty = document.getElementById('guess-difficulty').value;
                
                const diffStats = gameStats.data.guess[difficulty];
                const overallStats = gameStats.data.guess.overall;
                const diffBest = !diffStats.bestAttempts || this.attempts < diffStats.bestAttempts;
                const overallBest = !overallStats.bestAttempts || this.attempts < overallStats.bestAttempts;

                gameStats.updateGame('guess', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestAttempts: diffBest ? this.attempts : diffStats.bestAttempts,
                        totalTime: diffStats.totalTime + timePlayed,
                        wins: diffStats.wins + 1
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestAttempts: overallBest ? this.attempts : overallStats.bestAttempts,
                        totalTime: overallStats.totalTime + timePlayed,
                        wins: overallStats.wins + 1
                    },
                    timePlayed: timePlayed
                }, difficulty);

                document.getElementById('guess-feedback').textContent = `🎉 Correct! The number was ${this.secretNumber}. You got it in ${this.attempts} attempts!`;
                this.updateDisplay();
                this.playSound(523.25, 0.5);
                gameModal.show('🔢 Congratulations!', `You guessed ${this.secretNumber} in ${this.attempts} attempts!`, 'guess', this, this.difficulty);
            }

            updateDisplay() {
                document.getElementById('guess-attempts').textContent = this.attempts;
                const best = gameStats.data.guess.overall.bestAttempts;
                document.getElementById('guess-best').textContent = best || 'N/A';
            }

            updateHistory() {
                if (this.guessHistory.length === 0) return;
                
                const historyText = `Previous guesses: ${this.guessHistory.join(', ')}`;
                document.getElementById('guess-history').textContent = historyText;
            }

            showHints() {
                if (this.attempts < 3) return; // No hints for first 2 attempts
                
                const hintDiv = document.getElementById('guess-hints');
                const hintText = document.getElementById('hint-text');
                
                if (this.attempts >= 5) {
                    // Show narrow range hint after 5 attempts
                    hintText.textContent = `The number is between ${this.range.min} and ${this.range.max}`;
                    hintDiv.style.display = 'block';
                } else if (this.attempts >= 3) {
                    // Show general hint after 3 attempts
                    const isEven = this.secretNumber % 2 === 0;
                    hintText.textContent = `The number is ${isEven ? 'even' : 'odd'}`;
                    hintDiv.style.display = 'block';
                }
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let guessGame = new GuessGame();

        function startGuessing() {
            guessGame.start();
        }

        function makeGuess() {
            guessGame.makeGuess();
        }

        // Game 5: Typing Speed Test
        class TypingGame {
            constructor() {
                this.textCollections = {
                    easy: [
                        "The sun rose over the quiet town, casting a warm glow on the rooftops and gardens. Birds chirped as people began their day, some heading to work, others preparing breakfast for their families. The air was fresh and filled with the scent of blooming flowers, making everyone feel hopeful for the day ahead.",
                        "Children gathered in the park, their laughter echoing as they played games and chased each other around the swings. Parents watched from nearby benches, chatting and sipping coffee while keeping a watchful eye on their little ones. The playground was a place of joy and friendship, where memories were made every afternoon.",
                        "A gentle rain began to fall, tapping softly on windows and creating puddles on the sidewalks. People hurried along with umbrellas, some stopping to help others who had forgotten theirs. The rain brought a sense of calm, washing away the dust and leaving the world feeling refreshed and new.",
                        "The library was a haven for book lovers, its shelves filled with stories waiting to be discovered. Students studied quietly at tables, while others browsed for novels to take home. The librarian greeted everyone with a smile, happy to share her love of reading with the community.",
                        "On weekends, families visited the local farmers market, sampling fresh fruits and vegetables from nearby farms. Vendors offered homemade jams, breads, and cheeses, and the air was filled with the sounds of music and friendly conversation. It was a tradition that brought people together and supported local growers.",
                        "The old oak tree in the center of town was a favorite meeting spot for friends. Its branches provided shade on hot summer days, and its sturdy trunk was perfect for climbing. Generations of children had carved their initials into the bark, leaving a legacy for those who came after.",
                        "Every evening, neighbors gathered on their porches to share stories and enjoy the cool breeze. Some played guitars and sang songs, while others simply listened and laughed. These moments of connection made the neighborhood feel like a true community.",
                        "The bakery on Main Street was famous for its cinnamon rolls, which sold out quickly each morning. The smell of fresh bread and pastries drew customers from all over town, eager to start their day with a sweet treat. The baker took pride in her work, always striving to create something delicious.",
                        "During the winter, children built snowmen and had snowball fights in the park. Parents bundled up and joined in the fun, making memories that would last a lifetime. Hot chocolate was served in thermoses, warming everyone after a day of play in the cold.",
                        "The town’s annual parade was a highlight of the year, featuring colorful floats, marching bands, and local performers. Residents lined the streets to cheer and wave, celebrating their shared history and looking forward to the future. It was a day of pride and joy for all.",
                        "In spring, gardens burst into bloom with tulips, daffodils, and roses. People spent weekends planting seeds and tending to their flowers, eager to see the results of their hard work. The beauty of the gardens brought happiness to everyone who passed by.",
                        "The local animal shelter cared for dogs and cats in need of homes. Volunteers walked the animals, played with them, and helped find loving families to adopt them. The shelter was a place of hope, where every pet had a chance for a better life.",
                        "On rainy days, families gathered indoors to play board games and bake cookies. Laughter filled the house as everyone competed to win, and the smell of chocolate chip cookies made the day feel special. These simple pleasures brought families closer together.",
                        "The school’s art fair showcased paintings, sculptures, and crafts made by students. Parents and teachers admired the creativity and talent on display, proud of the hard work and imagination of their children. The event inspired everyone to appreciate the arts.",
                        "Summer brought picnics in the park, with blankets spread out under shady trees. Sandwiches, fruit, and lemonade were shared among friends, and children played frisbee and tag nearby. The long, sunny days were perfect for relaxing and enjoying nature.",
                        "The town’s history museum displayed artifacts and photographs from years past. Visitors learned about the people and events that shaped their community, gaining a deeper appreciation for their roots. The museum was a treasure trove of stories and memories.",
                        "Local artists painted murals on the sides of buildings, adding color and beauty to the streets. Residents admired the artwork as they walked by, proud of the creativity that made their town unique. The murals became landmarks and points of pride.",
                        "Autumn brought crisp air and falling leaves, which children collected to make colorful collages. Families visited pumpkin patches and apple orchards, enjoying the bounty of the season. The changing landscape signaled the start of cozy evenings at home.",
                        "The community center hosted classes and events for people of all ages. From yoga to cooking lessons, there was something for everyone to enjoy. The center was a hub of activity, fostering friendships and lifelong learning.",
                        "On clear nights, families gathered to stargaze and learn about constellations. Telescopes were set up in backyards, and children marveled at the wonders of the universe. These moments sparked curiosity and dreams of exploring the stars."
                    ],
                    medium: [
                        "Technology has revolutionized communication, making it possible to connect instantly with people around the world. Social media platforms allow users to share ideas, photos, and experiences, fostering global communities. However, these advances also raise concerns about privacy, security, and the impact of digital interactions on mental health.",
                        "Climate change is one of the most pressing issues facing humanity today. Rising temperatures, melting ice caps, and extreme weather events threaten ecosystems and communities worldwide. Governments, businesses, and individuals must work together to reduce carbon emissions and promote sustainable practices.",
                        "Education is the foundation of personal and societal growth. Schools and universities provide opportunities for learning, critical thinking, and skill development. Lifelong learning is essential in a rapidly changing world, helping people adapt to new challenges and pursue their passions.",
                        "The internet has transformed how we access information, shop, and entertain ourselves. Online resources make it easy to learn new skills, find products, and connect with others. E-commerce has changed the retail landscape, offering convenience and variety to consumers everywhere.",
                        "Healthy living involves regular exercise, balanced nutrition, and mental wellness. People are increasingly aware of the importance of self-care, seeking ways to improve their physical and emotional health. Community programs and online resources support individuals in making positive lifestyle changes.",
                        "Traveling exposes us to new cultures, languages, and perspectives. Exploring different countries and regions broadens our understanding of the world and fosters empathy. Tourism also supports local economies, creating jobs and promoting cultural exchange.",
                        "Art and music enrich our lives, providing outlets for creativity and self-expression. Museums, galleries, and concert halls showcase the talents of artists and performers, inspiring audiences and fostering appreciation for the arts. Creative activities also support mental health and personal growth.",
                        "Teamwork is essential in both professional and personal settings. Collaborating with others leads to better outcomes, as diverse perspectives and skills contribute to problem-solving. Effective communication and mutual respect are key to successful teamwork.",
                        "Environmental conservation protects natural resources and preserves biodiversity. Recycling, reducing waste, and supporting renewable energy are important steps in safeguarding the planet. Conservation efforts benefit future generations and ensure a healthy environment for all.",
                        "Volunteering strengthens communities by addressing local needs and supporting vulnerable populations. Volunteers contribute time, skills, and resources to causes they care about, making a positive impact on society. Community service fosters empathy, leadership, and a sense of purpose.",
                        "Innovation drives progress in science, technology, and business. Inventors and entrepreneurs develop new products and solutions that improve lives and solve complex problems. A culture of innovation encourages creativity, risk-taking, and continuous improvement.",
                        "Reading expands our knowledge and imagination, transporting us to different worlds and perspectives. Libraries and bookstores offer access to a wide range of literature, from fiction to nonfiction. Reading also improves language skills and cognitive abilities.",
                        "Cooking is both an art and a science, combining creativity with technical skill. Home cooks and professional chefs experiment with flavors, ingredients, and techniques to create delicious meals. Cooking brings people together, fostering connection and celebration.",
                        "Sports promote physical fitness, teamwork, and discipline. Athletes train hard to achieve their goals, inspiring others to pursue active lifestyles. Sporting events unite communities, providing entertainment and opportunities for friendly competition.",
                        "Gardening connects people with nature, offering relaxation and a sense of accomplishment. Growing flowers, vegetables, and herbs provides fresh produce and beautifies outdoor spaces. Gardening also supports environmental sustainability and biodiversity.",
                        "Financial literacy is essential for managing money, planning for the future, and achieving personal goals. Understanding budgeting, saving, and investing helps individuals make informed decisions and avoid financial pitfalls. Education and resources support financial well-being.",
                        "Public transportation reduces traffic congestion and pollution, making cities more livable. Buses, trains, and subways provide affordable and efficient travel options for millions of people. Investments in public transit support economic growth and environmental sustainability.",
                        "Mental health awareness is growing, with more people seeking support and resources for emotional well-being. Therapy, mindfulness, and community programs help individuals cope with stress, anxiety, and depression. Reducing stigma encourages open conversations and access to care.",
                        "Entrepreneurship creates jobs, drives innovation, and fuels economic growth. Small businesses and startups bring new ideas to market, challenging established industries and fostering competition. Supportive policies and resources help entrepreneurs succeed.",
                        "Science explores the mysteries of the universe, from the smallest particles to the largest galaxies. Researchers conduct experiments, analyze data, and develop theories to expand our understanding of the natural world. Scientific discoveries improve technology, medicine, and quality of life."
                    ],
                    hard: [
                        "Philosophical inquiry delves into the nature of existence, knowledge, and ethics. Thinkers debate concepts such as free will, consciousness, and morality, seeking to understand the foundations of human experience. These discussions shape our worldview and influence cultural, scientific, and political developments.",
                        "Quantum mechanics challenges classical notions of reality, introducing concepts like superposition, entanglement, and uncertainty. Experiments reveal the probabilistic nature of particles, prompting new theories about the structure of matter and the universe. Quantum technologies promise advances in computing, communication, and cryptography.",
                        "Poststructuralist theory critiques traditional approaches to language, meaning, and interpretation. Scholars analyze texts to uncover hidden assumptions, power dynamics, and cultural influences. This perspective encourages critical thinking and challenges established norms in literature, philosophy, and social sciences.",
                        "Neuroplasticity demonstrates the brain’s ability to reorganize and adapt throughout life. Research shows that learning, experience, and injury can alter neural pathways, influencing behavior and cognition. Understanding neuroplasticity informs treatments for neurological disorders and supports lifelong learning.",
                        "Macroeconomic analysis examines the interactions between governments, markets, and consumers. Economists study fiscal and monetary policies, trade dynamics, and global trends to predict growth, inflation, and unemployment. These insights guide decision-making in business, finance, and public policy.",
                        "Epigenetics explores how environmental factors influence gene expression without altering DNA sequences. Scientists investigate the role of diet, stress, and toxins in shaping health outcomes across generations. Epigenetic research informs personalized medicine and public health strategies.",
                        "Renewable energy technologies harness natural resources such as sunlight, wind, and water to generate power. Engineers develop efficient systems to reduce reliance on fossil fuels, combat climate change, and promote sustainability. The transition to clean energy requires innovation, investment, and global cooperation.",
                        "Artificial intelligence integrates machine learning, data analysis, and automation to solve complex problems. AI systems recognize patterns, make predictions, and optimize processes in fields ranging from healthcare to transportation. Ethical considerations guide the development and deployment of intelligent technologies.",
                        "Statistical modeling enables researchers to analyze data, identify trends, and make informed decisions. Techniques such as regression, hypothesis testing, and probability theory support scientific inquiry and business strategy. Mastery of statistics is essential for interpreting research and evaluating evidence.",
                        "Hermeneutics investigates the interpretation of texts, symbols, and cultural artifacts. Scholars explore historical context, authorial intent, and reader response to uncover layers of meaning. Hermeneutic analysis enriches our understanding of literature, philosophy, and religion.",
                        "Existential philosophy examines themes of freedom, authenticity, and responsibility. Thinkers like Sartre and Camus explore the challenges of living a meaningful life in an uncertain world. Existentialism inspires reflection on personal values, choices, and the search for purpose.",
                        "Environmental science studies the impact of human activity on ecosystems, climate, and biodiversity. Researchers assess pollution, resource depletion, and conservation efforts to inform policy and promote sustainability. Protecting the environment is vital for the health of current and future generations.",
                        "International relations analyze the interactions between countries, organizations, and individuals. Diplomacy, trade, and conflict resolution shape global politics and influence economic development. Understanding international relations is essential for navigating a complex and interconnected world.",
                        "Critical thinking involves evaluating information, identifying biases, and making reasoned judgments. Educators encourage students to question assumptions, analyze arguments, and solve problems creatively. Critical thinking skills are crucial for academic success and informed citizenship.",
                        "Cognitive behavioral therapy (CBT) is a psychological treatment that helps individuals manage anxiety, depression, and other mental health issues. CBT teaches coping strategies, challenges negative thought patterns, and promotes emotional resilience. Therapists use CBT to support recovery and improve quality of life.",
                        "Strategic planning guides organizations in setting goals, allocating resources, and measuring progress. Leaders develop strategies to respond to challenges, seize opportunities, and achieve long-term success. Effective planning requires analysis, collaboration, and adaptability.",
                        "Sustainable development balances economic growth, environmental protection, and social equity. Policymakers design initiatives to reduce poverty, promote clean energy, and ensure access to education and healthcare. Sustainable practices benefit communities and preserve resources for future generations.",
                        "Empirical research relies on observation, experimentation, and data analysis to test hypotheses and build knowledge. Scientists use rigorous methods to ensure accuracy, reliability, and validity in their findings. Empirical evidence supports scientific theories and informs decision-making.",
                        "Semantic analysis examines the meaning of words, phrases, and texts. Linguists study language structure, context, and usage to understand communication and interpretation. Semantic research informs fields such as artificial intelligence, translation, and education.",
                        "Systems theory explores the relationships and interactions within complex networks. Researchers model systems in biology, engineering, and social sciences to predict behavior and optimize performance. Systems thinking supports problem-solving and innovation across disciplines."
                    ],
                    code: [
                        "function calculateSum(array) { return array.reduce((acc, val) => acc + val, 0); }",
                        "const apiResponse = await fetch('/api/users').then(r => r.json()).catch(e => console.error(e));",
                        "class DatabaseManager { constructor(connStr) { this.conn = new Connection(connStr); } async query(sql, params) { return await this.conn.execute(sql, params); } }",
                        "import React, { useState, useEffect } from 'react'; const Component = () => { const [data, setData] = useState([]); useEffect(() => { fetchData().then(setData); }, []); return <div>{data.map(item => <span key={item.id}>{item.name}</span>)}</div>; };",
                        "SELECT u.username, p.title, COUNT(c.id) as comment_count FROM users u INNER JOIN posts p ON u.id = p.user_id LEFT JOIN comments c ON p.id = c.post_id WHERE p.created_at >= '2023-01-01' GROUP BY u.id, p.id ORDER BY comment_count DESC LIMIT 10;"
                    ]
                };
            this.currentText = '';
    this.startTime = 0;
    this.timeRemaining = 60;
    this.isTyping = false;
    this.interval = null;
    this.difficulty = 'medium';
    this.promptsCompleted = 0;
    this.totalCorrectChars = 0;
    this.totalTypedChars = 0;
    this.totalErrors = 0;
    this.wpmHistory = { easy: [], medium: [], hard: [], code: [] };
}

// Show WPM and score on results modal
showResultsModal() {
    const wpm = document.getElementById('typing-wpm').textContent;
    const accuracy = document.getElementById('typing-accuracy').textContent;
    const errors = document.getElementById('typing-errors').textContent;
    const modal = document.getElementById('game-modal');
    const scoreElem = document.getElementById('modal-score');
    scoreElem.innerHTML = `
        <h2>Test Complete!</h2>
        <div style="font-size:1.3rem;margin-bottom:10px;"><strong>WPM:</strong> ${wpm} | <strong>Accuracy:</strong> ${accuracy} | <strong>Errors:</strong> ${errors}</div>
        <div style="margin-top:10px;font-size:0.9rem;opacity:0.7;">Press Enter to play again, Escape to return to menu</div>
    `;
    modal.style.display = 'block';
}

            start() {
                if (this.isTyping) {
                    clearInterval(this.interval);
                    this.reset();
                }
                const duration = parseInt(document.getElementById('typing-duration').value);
                this.difficulty = document.getElementById('typing-difficulty').value;
                this.timeRemaining = duration;
                this.promptsCompleted = 0;
                this.totalCorrectChars = 0;
                this.totalTypedChars = 0;
                this.totalErrors = 0;
                this.startTime = Date.now();
                this.isTyping = true;
                this.nextText();
                const input = document.getElementById('typing-input');
                input.disabled = false;
                input.value = '';
                input.focus();
                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.updateStats();
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('typing-timer').textContent = this.timeRemaining;

                if (this.timeRemaining <= 0) {
                    this.endTest();
                }
            }

            handleInput() {
                if (!this.isTyping) return;
                const input = document.getElementById('typing-input');
                const typed = input.value;
                // Count correct characters for this prompt
                let correct = 0;
                for (let i = 0; i < Math.min(typed.length, this.currentText.length); i++) {
                    if (typed[i] === this.currentText[i]) correct++;
                }
                // Check if current text is completed
                if (typed.length >= this.currentText.length && typed === this.currentText) {
                    this.promptsCompleted++;
                    this.totalCorrectChars += correct;
                    this.totalTypedChars += typed.length;
                    this.totalErrors += (typed.length - correct);
                    this.nextText();
                    input.value = '';
                } else {
                    // Update running totals for current prompt
                    this.totalCorrectChars += correct - (this.totalCorrectChars % (this.currentText.length+1));
                    this.totalTypedChars += typed.length - (this.totalTypedChars % (this.currentText.length+1));
                    this.totalErrors += (typed.length - correct) - (this.totalErrors % (this.currentText.length+1));
                }
                this.updateStats();
                this.updateTextDisplay(typed);
            }

            nextText() {
                // Get a new random text from current difficulty
                const textCollection = this.textCollections[this.difficulty];
                this.currentText = textCollection[Math.floor(Math.random() * textCollection.length)];
                
                // Clear input and reset display
                const input = document.getElementById('typing-input');
                input.value = '';
                
                // Update display
                document.getElementById('typing-text').textContent = this.currentText;
                
                // Play completion sound
                this.playSound(659.25, 0.2);
            }

            updateTextDisplay(typed) {
                const textDiv = document.getElementById('typing-text');
                let html = '';

                for (let i = 0; i < this.currentText.length; i++) {
                    if (i < typed.length) {
                        if (typed[i] === this.currentText[i]) {
                            html += `<span style="background-color: rgba(76, 175, 80, 0.3);">${this.currentText[i]}</span>`;
                        } else {
                            html += `<span style="background-color: rgba(244, 67, 54, 0.3);">${this.currentText[i]}</span>`;
                        }
                    } else if (i === typed.length) {
                        html += `<span style="background-color: rgba(255, 255, 255, 0.3);">${this.currentText[i]}</span>`;
                    } else {
                        html += this.currentText[i];
                    }
                }

                textDiv.innerHTML = html;
            }

            updateStats() {
                const timeElapsed = (Date.now() - this.startTime) / 1000 / 60; // minutes
                const words = Math.max(this.totalCorrectChars / 5, 0);
                const rawWords = Math.max(this.totalTypedChars / 5, 0);
                const wpm = timeElapsed > 0 ? Math.round(words / timeElapsed) : 0;
                const rawWpm = timeElapsed > 0 ? Math.round(rawWords / timeElapsed) : 0;
                const accuracy = this.totalTypedChars > 0 ? Math.round((this.totalCorrectChars / this.totalTypedChars) * 100) : 100;
                document.getElementById('typing-wpm').textContent = wpm;
                document.getElementById('typing-raw-wpm').textContent = rawWpm;
                document.getElementById('typing-accuracy').textContent = accuracy + '%';
                document.getElementById('typing-errors').textContent = this.totalErrors;
                // Track WPM per difficulty
                if (this.isTyping && this.promptsCompleted > 0) {
                    this.wpmHistory[this.difficulty].push(wpm);
                }
            }

            endTest() {
                this.isTyping = false;
                clearInterval(this.interval);
                
                const input = document.getElementById('typing-input');
                input.disabled = true;

                const timeElapsed = (Date.now() - this.startTime) / 1000 / 60;
                const words = Math.max(this.correctChars / 5, 0);
                const wpm = timeElapsed > 0 ? Math.round(words / timeElapsed) : 0;
                const accuracy = this.totalChars > 0 ? Math.round((this.correctChars / this.totalChars) * 100) : 100;

                const duration = parseInt(document.getElementById('typing-duration').value);
                const diffStats = gameStats.data.typing[duration];
                const overallStats = gameStats.data.typing.overall;
                const timePlayed = Date.now() - this.startTime;

                gameStats.updateGame('typing', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        bestWPM: Math.max(diffStats.bestWPM, wpm),
                        bestAccuracy: Math.max(diffStats.bestAccuracy, accuracy),
                        totalTime: diffStats.totalTime + timePlayed,
                        tests: [...diffStats.tests.slice(-19), { wpm, accuracy }]
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        bestWPM: Math.max(overallStats.bestWPM, wpm),
                        bestAccuracy: Math.max(overallStats.bestAccuracy, accuracy),
                        totalTime: overallStats.totalTime + timePlayed,
                        tests: [...overallStats.tests.slice(-19), { wpm, accuracy }]
                    },
                    timePlayed: timePlayed
                }, duration);

                this.playSound(523.25, 0.5);
                gameModal.show('⌨️ Test Complete!', `WPM: ${wpm}<br>Accuracy: ${accuracy}%<br>Errors: ${this.errors}`, 'typing', this);
            }

            reset() {
                this.isTyping = false;
                clearInterval(this.interval);
                document.getElementById('typing-input').disabled = true;
                document.getElementById('typing-input').value = '';
                document.getElementById('typing-text').textContent = 'Press "Start Test" to begin typing challenge';
                document.getElementById('typing-wpm').textContent = '0';
                document.getElementById('typing-raw-wpm').textContent = '0';
                document.getElementById('typing-accuracy').textContent = '100%';
                document.getElementById('typing-errors').textContent = '0';
                document.getElementById('typing-timer').textContent = '60';
                // Save high score per difficulty
                Object.keys(this.wpmHistory).forEach(diff => {
                    if (this.wpmHistory[diff].length > 0) {
                        const bestWPM = Math.max(...this.wpmHistory[diff]);
                        // Save to stats (pseudo code, adapt to your stats system)
                        if (window.gameStats && window.gameStats.data && window.gameStats.data.typing && window.gameStats.data.typing[diff]) {
                            if (bestWPM > (window.gameStats.data.typing[diff].bestWPM || 0)) {
                                window.gameStats.data.typing[diff].bestWPM = bestWPM;
                                window.gameStats.saveStats();
                            }
                        }
                    }
                });
                this.wpmHistory = { easy: [], medium: [], hard: [], code: [] };
            }


            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let typingGame = new TypingGame();

        function startTyping() {
            typingGame.start();
        }

        function resetTyping() {
            typingGame.reset();
        }

        // Game 6: Color Matcher Game
        class ColorGame {
            constructor() {
                this.colors = [
                    { name: 'RED', value: '#f44336' },
                    { name: 'BLUE', value: '#2196F3' },
                    { name: 'GREEN', value: '#4CAF50' },
                    { name: 'YELLOW', value: '#FFEB3B' },
                    { name: 'PURPLE', value: '#9C27B0' },
                    { name: 'ORANGE', value: '#FF9800' }
                ];
                this.currentColor = null;
                this.score = 0;
                this.streak = 0;
                this.gameRunning = false;
                this.startTime = null;
                this.timeRemaining = 30;
                this.interval = null;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    clearInterval(this.interval);
                }
                this.score = 0;
                this.streak = 0;
                this.timeRemaining = 30;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.nextRound();
                this.updateDisplay();
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('color-timer').textContent = this.timeRemaining;
                
                if (this.timeRemaining <= 0) {
                    this.endGame();
                }
            }

            nextRound() {
                if (!this.gameRunning) return;

                // Choose random color name and random color for display
                const nameColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                const displayColor = this.colors[Math.floor(Math.random() * this.colors.length)];

                this.currentColor = nameColor;
                const wordDiv = document.getElementById('color-word');
                wordDiv.textContent = nameColor.name;
                wordDiv.style.color = displayColor.value;

                document.getElementById('color-feedback').textContent = 'Match the meaning of the word, not its color!';
            }

            selectColor(colorName) {
                if (!this.gameRunning) return;

                const correct = colorName === this.currentColor.name.toLowerCase();
                
                if (correct) {
                    this.score += 10 + this.streak;
                    this.streak++;
                    this.playSound(523.25, 0.1);
                    document.getElementById('color-feedback').textContent = `Correct! +${10 + this.streak - 1} points`;
                } else {
                    this.streak = 0;
                    this.playSound(220, 0.2);
                    document.getElementById('color-feedback').textContent = `Wrong! The answer was ${this.currentColor.name.toLowerCase()}`;
                }

                gameStats.updateGame('color', {
                    gamesPlayed: gameStats.data.color.gamesPlayed,
                    highScore: Math.max(gameStats.data.color.highScore, this.score),
                    bestStreak: Math.max(gameStats.data.color.bestStreak, this.streak),
                    totalTime: gameStats.data.color.totalTime,
                    correct: gameStats.data.color.correct + (correct ? 1 : 0),
                    total: gameStats.data.color.total + 1
                });

                this.updateDisplay();
                
                setTimeout(() => this.nextRound(), 1500);
            }

            updateDisplay() {
                document.getElementById('color-score').textContent = this.score;
                document.getElementById('color-streak').textContent = this.streak;
            }

            endGame() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                const timePlayed = Date.now() - this.startTime;
                gameStats.updateGame('color', {
                    gamesPlayed: gameStats.data.color.gamesPlayed + 1,
                    highScore: Math.max(gameStats.data.color.highScore, this.score),
                    bestStreak: Math.max(gameStats.data.color.bestStreak, this.streak),
                    totalTime: gameStats.data.color.totalTime + timePlayed
                });

                gameModal.show('🎨 Time\'s Up!', `Final Score: ${this.score}<br>Best Streak: ${this.streak}`, 'color', this);
            }

            reset() {
                this.gameRunning = false;
                clearInterval(this.interval);
                this.score = 0;
                this.streak = 0;
                this.timeRemaining = 30;
                this.currentColor = null;

                document.getElementById('color-word').textContent = 'RED';
                document.getElementById('color-word').style.color = '#f44336';
                document.getElementById('color-feedback').textContent = 'Match the meaning of the word, not its color!';
                document.getElementById('color-timer').textContent = '30';
                this.updateDisplay();
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let colorGame = new ColorGame();

        function startColorMatch() {
            colorGame.start();
        }

        function selectColor(color) {
            colorGame.selectColor(color);
        }

        function resetColorMatch() {
            colorGame.reset();
        }

        // Game 7: Math Quiz
        class MathGame {
            constructor() {
                this.score = 0;
                this.timeRemaining = 30;
                this.gameRunning = false;
                this.interval = null;
                this.startTime = null;
                this.currentAnswer = 0;
                this.totalQuestions = 0;
                this.correctAnswers = 0;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    clearInterval(this.interval);
                    this.reset();
                }
                
                this.score = 0;
                this.timeRemaining = 30;
                this.gameRunning = true;
                this.startTime = Date.now();
                this.totalQuestions = 0;
                this.correctAnswers = 0;

                document.getElementById('math-input').disabled = false;
                document.getElementById('math-input').value = '';
                
                this.interval = setInterval(() => this.updateTimer(), 1000);
                this.generateQuestion();
                this.updateDisplay();
            }

            generateQuestion() {
                const difficulty = document.getElementById('math-difficulty').value;
                let num1, num2, operation, question;

                switch (difficulty) {
                    case 'easy':
                        num1 = Math.floor(Math.random() * 20) + 1;
                        num2 = Math.floor(Math.random() * 20) + 1;
                        operation = Math.random() < 0.5 ? '+' : '-';
                        break;
                    case 'medium':
                        num1 = Math.floor(Math.random() * 50) + 1;
                        num2 = Math.floor(Math.random() * 50) + 1;
                        const operations = ['+', '-', '×'];
                        operation = operations[Math.floor(Math.random() * operations.length)];
                        break;
                    case 'hard':
                        num1 = Math.floor(Math.random() * 100) + 1;
                        num2 = Math.floor(Math.random() * 20) + 1;
                        const allOps = ['+', '-', '×', '÷'];
                        operation = allOps[Math.floor(Math.random() * allOps.length)];
                        if (operation === '÷') {
                            num1 = num2 * (Math.floor(Math.random() * 10) + 1);
                        }
                        break;
                }

                switch (operation) {
                    case '+':
                        this.currentAnswer = num1 + num2;
                        question = `${num1} + ${num2}`;
                        break;
                    case '-':
                        if (num1 < num2) [num1, num2] = [num2, num1];
                        this.currentAnswer = num1 - num2;
                        question = `${num1} - ${num2}`;
                        break;
                    case '×':
                        this.currentAnswer = num1 * num2;
                        question = `${num1} × ${num2}`;
                        break;
                    case '÷':
                        this.currentAnswer = num1 / num2;
                        question = `${num1} ÷ ${num2}`;
                        break;
                }

                document.getElementById('math-question').textContent = question + ' = ?';
            }

            submitAnswer() {
                if (!this.gameRunning) return;

                const input = document.getElementById('math-input');
                const userAnswer = parseFloat(input.value);

                this.totalQuestions++;

                if (userAnswer === this.currentAnswer) {
                    this.score += 5;
                    this.correctAnswers++;
                    this.playSound(523.25, 0.1);
                } else {
                    this.playSound(220, 0.1);
                }

                input.value = '';
                this.updateDisplay();
                this.generateQuestion();
            }

            skipQuestion() {
                if (!this.gameRunning) return;

                this.totalQuestions++;
                document.getElementById('math-input').value = '';
                this.generateQuestion();
                this.playSound(330, 0.1);
            }

            updateTimer() {
                this.timeRemaining--;
                document.getElementById('math-timer').textContent = this.timeRemaining;

                if (this.timeRemaining <= 0) {
                    this.endGame();
                }
            }

            updateDisplay() {
                document.getElementById('math-score').textContent = this.score;
            }

            endGame() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                document.getElementById('math-input').disabled = true;
                document.getElementById('math-question').textContent = 'Game Over!';

                const accuracy = this.totalQuestions > 0 ? Math.round((this.correctAnswers / this.totalQuestions) * 100) : 0;

                const difficulty = document.getElementById('math-difficulty').value;
                const diffStats = gameStats.data.math[difficulty];
                const overallStats = gameStats.data.math.overall;
                const timePlayed = Date.now() - this.startTime;

                gameStats.updateGame('math', {
                    difficulty: {
                        gamesPlayed: diffStats.gamesPlayed + 1,
                        highScore: Math.max(diffStats.highScore, this.score),
                        totalTime: diffStats.totalTime + timePlayed,
                        correct: diffStats.correct + this.correctAnswers,
                        total: diffStats.total + this.totalQuestions
                    },
                    overall: {
                        gamesPlayed: overallStats.gamesPlayed + 1,
                        highScore: Math.max(overallStats.highScore, this.score),
                        totalTime: overallStats.totalTime + timePlayed,
                        correct: overallStats.correct + this.correctAnswers,
                        total: overallStats.total + this.totalQuestions
                    },
                    timePlayed: timePlayed
                }, difficulty);

                this.playSound(523.25, 0.5);
                gameModal.show('➕ Time\'s Up!', `Score: ${this.score}<br>Questions: ${this.totalQuestions}<br>Accuracy: ${accuracy}%`, 'math', this);
            }

            reset() {
                this.gameRunning = false;
                clearInterval(this.interval);
                
                this.score = 0;
                this.timeRemaining = 30;
                this.totalQuestions = 0;
                this.correctAnswers = 0;

                document.getElementById('math-input').disabled = true;
                document.getElementById('math-input').value = '';
                document.getElementById('math-question').textContent = 'Press Start to Begin';
                document.getElementById('math-timer').textContent = '30';
                this.updateDisplay();
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let mathGame = new MathGame();

        function startMath() {
            mathGame.start();
        }

        function submitMath() {
            mathGame.submitAnswer();
        }

        function skipMath() {
            mathGame.skipQuestion();
        }

        function resetMath() {
            mathGame.reset();
        }

        // Game 8: Simon Says
        class SimonGame {
            constructor() {
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                this.gameRunning = false;
                this.showingSequence = false;
                this.difficulty = 'medium';
                this.allColors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'cyan', 'pink'];
                this.colors = ['red', 'blue', 'green', 'yellow']; // Will be set based on difficulty
                this.sounds = {
                    red: 220,
                    blue: 277.18,
                    green: 329.63,
                    yellow: 369.99,
                    purple: 415.30,
                    orange: 466.16,
                    cyan: 523.25,
                    pink: 587.33
                };
                this.difficultySettings = {
                    easy: { colors: 4, speed: { pause: 150, show: 250 } },
                    medium: { colors: 4, speed: { pause: 100, show: 200 } },
                    hard: { colors: 6, speed: { pause: 80, show: 180 } },
                    expert: { colors: 8, speed: { pause: 60, show: 150 } }
                };
                this.startTime = null;
            }

            start() {
                if (this.gameRunning) {
                    // Reset if already running
                    this.reset();
                }
                
                this.difficulty = document.getElementById('simon-difficulty').value;
                this.setupDifficulty();
                
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                this.gameRunning = true;
                this.startTime = Date.now();
                
                document.getElementById('simon-status').textContent = 'Watch the sequence...';
                this.updateDisplay();
                this.nextLevel();
            }

            setupDifficulty() {
                const settings = this.difficultySettings[this.difficulty];
                const numColors = settings.colors;
                this.colors = this.allColors.slice(0, numColors);
                
                // Show/hide buttons based on difficulty
                document.querySelectorAll('.simon-button').forEach((button, index) => {
                    if (index < numColors) {
                        button.style.display = 'block';
                    } else {
                        button.style.display = 'none';
                    }
                });
            }

            nextLevel() {
                if (!this.gameRunning) return;
                
                this.level++;
                this.playerSequence = [];
                
                // Add new color to sequence
                const randomColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                this.sequence.push(randomColor);
                
                this.updateDisplay();
                document.getElementById('simon-status').textContent = `Level ${this.level} - Watch carefully!`;
                
                setTimeout(() => this.showSequence(), 1000);
            }

            async showSequence() {
                this.showingSequence = true;
                const settings = this.difficultySettings[this.difficulty];
                
                for (let i = 0; i < this.sequence.length; i++) {
                    await this.sleep(settings.speed.pause);
                    this.activateButton(this.sequence[i]);
                    await this.sleep(settings.speed.show);
                    this.deactivateButton(this.sequence[i]);
                }
                
                this.showingSequence = false;
                document.getElementById('simon-status').textContent = 'Now repeat the sequence!';
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            activateButton(color) {
                const button = document.querySelector(`.simon-button.${color}`);
                button.classList.add('active');
                this.playSound(this.sounds[color], 0.3);
            }

            deactivateButton(color) {
                const button = document.querySelector(`.simon-button.${color}`);
                button.classList.remove('active');
            }

            buttonClick(color) {
                if (!this.gameRunning || this.showingSequence) return;

                this.activateButton(color);
                setTimeout(() => this.deactivateButton(color), 200);

                this.playerSequence.push(color);
                const currentIndex = this.playerSequence.length - 1;

                if (this.playerSequence[currentIndex] !== this.sequence[currentIndex]) {
                    this.gameOver();
                    return;
                }

                if (this.playerSequence.length === this.sequence.length) {
                    document.getElementById('simon-status').textContent = 'Correct! Next level coming...';
                    setTimeout(() => this.nextLevel(), 1500);
                }
            }

            gameOver() {
                this.gameRunning = false;
                this.showingSequence = false;
                this.playerSequence = [];
                const timePlayed = Date.now() - this.startTime;
                const finalLevel = this.level;

                // Update difficulty-specific stats
                const diffStats = gameStats.data.simon[this.difficulty];
                gameStats.data.simon[this.difficulty] = {
                    gamesPlayed: diffStats.gamesPlayed + 1,
                    highLevel: Math.max(diffStats.highLevel, finalLevel),
                    totalTime: diffStats.totalTime + timePlayed,
                    levels: [...diffStats.levels.slice(-19), finalLevel]
                };

                // Update overall stats
                const overallStats = gameStats.data.simon.overall;
                gameStats.data.simon.overall = {
                    gamesPlayed: overallStats.gamesPlayed + 1,
                    highLevel: Math.max(overallStats.highLevel, finalLevel),
                    totalTime: overallStats.totalTime + timePlayed,
                    levels: [...overallStats.levels.slice(-19), finalLevel],
                    lastPlayed: Date.now()
                };

                gameStats.saveStats();

                this.playSound(150, 0.8);
                document.getElementById('simon-status').textContent = `❌ Wrong! Game Over! You reached level ${finalLevel}`;
                this.updateDisplay();
                
                // Enable start button
                document.getElementById('simon-start').disabled = false;
                
                gameModal.show('🎵 Game Over!', `You reached level ${finalLevel}`, 'simon', this, this.difficulty);
            }

            reset() {
                this.gameRunning = false;
                this.showingSequence = false;
                this.sequence = [];
                this.playerSequence = [];
                this.level = 0;
                
                document.querySelectorAll('.simon-button').forEach(button => {
                    button.classList.remove('active');
                });
                
                document.getElementById('simon-status').textContent = 'Press Start to begin the sequence';
                this.updateDisplay();
            }

            updateDisplay() {
                document.getElementById('simon-level').textContent = Math.max(this.level - 1, 0);
                document.getElementById('simon-best').textContent = gameStats.data.simon.highLevel;
            }

            playSound(frequency, duration) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not supported');
                }
            }
        }

        let simonGame = new SimonGame();

        function startSimon() {
            simonGame.start();
        }

        function simonClick(color) {
            simonGame.buttonClick(color);
        }

        function resetSimon() {
            simonGame.reset();
        }

        // Initialize games when page loads
        document.addEventListener('DOMContentLoaded', function() {
            gameStats.updateGlobalStats();
            
            // Initialize Snake game canvas
            setTimeout(() => {
                snakeGame = new SnakeGame();
            }, 100);

            // Setup Enter key for number guessing
            document.getElementById('guess-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') makeGuess();
            });

            // Setup typing input handler
            document.getElementById('typing-input').addEventListener('input', function() {
                typingGame.handleInput();
            });

            // Setup math input handler
            document.getElementById('math-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') submitMath();
            });

            // Initialize all game displays
            typingGame.reset();
            mathGame.reset();
            simonGame.updateDisplay();
        });
    </script>

    <!-- Game Completion Modal -->
    <div id="game-modal" class="game-modal">
        <div class="modal-content">
            <div class="modal-title" id="modal-title">🎉 Game Complete!</div>
            <div class="modal-score" id="modal-score">Your score: 100</div>
            <div class="modal-buttons">
                <button class="modal-btn primary" onclick="gameModal.restartGame()">🔄 Play Again</button>
                <button class="modal-btn" onclick="gameModal.goToMenu()">🏠 Main Menu</button>
                <button class="modal-btn" onclick="gameModal.changeDifficulty()">⚙️ Settings</button>
            </div>
        </div>
    </div>
</body>
</html>
